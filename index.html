<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  
  <title>张维尊的博客</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  <meta name="description" content="纸上得来终觉浅，绝知此事要躬行">
<meta property="og:type" content="website">
<meta property="og:title" content="张维尊的博客">
<meta property="og:url" content="https://zwz522623.github.io.git/index.html">
<meta property="og:site_name" content="张维尊的博客">
<meta property="og:description" content="纸上得来终觉浅，绝知此事要躬行">
<meta property="og:locale" content="zh_CN">
<meta property="article:author" content="ZWZ">
<meta name="twitter:card" content="summary">
  
    <link rel="alternate" href="/atom.xml" title="张维尊的博客" type="application/atom+xml">
  
  
    <link rel="icon" href="/favicon.png">
  
  
    <link href="//fonts.googleapis.com/css?family=Source+Code+Pro" rel="stylesheet" type="text/css">
  
  
<link rel="stylesheet" href="/css/style.css">

  
<link rel="stylesheet" href="/plugin/bganimation/bg.css">

  

  <link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.10.0/katex.min.css" rel="stylesheet" type="text/css">
<meta name="generator" content="Hexo 4.2.1"></head>

<body>
  <div id="container">
    <div id="wrap">
      <div class="outer">
        <div class="widget-wrap mobile-header">
  <h3 class="widget-title"></h3>
  <div class="widget">
    <img class="avatar" src="https://avatars0.githubusercontent.com/u/20333903?v=3&amp;s=460">
    <h2 class="author">ZWZ</h2>
    <h3 class="description">纸上得来终觉浅，绝知此事要躬行</h3>
    <div class="count-box">
      <a href="/archives"><div><strong>11</strong><br>文章</div></a>
      <a href="/categories"><div><strong>0</strong><br>分类</div></a>
      <a href="/tags"><div><strong>0</strong><br>标签</div></a>
    </div>
    <ul class="blog-link">
     
          <a href="/" title="Home">
            <li>主页</li>
          </a>
        
          <a href="/archives" title="Archives">
            <li>归档</li>
          </a>
        
          <a href="/categories" title="Categories">
            <li>分类</li>
          </a>
        
          <a href="/tags" title="Tags">
            <li>标签</li>
          </a>
        
    </ul>
  </div>
</div>

        <section id="main">
  
    <article id="post-基本定时器" class="wow slideInRight article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2020/07/28/%E5%9F%BA%E6%9C%AC%E5%AE%9A%E6%97%B6%E5%99%A8/" class="article-date">
  <time class="post-time" datetime="2020-07-28T09:48:55.601Z" itemprop="datePublished">
    <span class="post-month">7月</span><br/>
    <span class="post-day">28</span>
  </time>
</a>
   
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2020/07/28/%E5%9F%BA%E6%9C%AC%E5%AE%9A%E6%97%B6%E5%99%A8/">基本定时器</a>
    </h1>
  

        <div>
          
          
              

          
        </div>
      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>STM32的定时器分类有以下三种：<br>(1):基本定时器(只有定时功能)<br>(2):通用定时器(输出比较，输入捕获)<br>(3):高级定时器(包括了基本定时器与通用定时器)</p>
<h2 id="基本定时器特性"><a href="#基本定时器特性" class="headerlink" title="基本定时器特性"></a>基本定时器特性</h2><p>1)16BIT计数器，只能向上计数，通道只有定时器TIM6与TIM7.<br>2)内部资源，没有外部的GPIO,只能定时。<br>3)时钟来自PCLK1,为72M,可实现1-65536分频。</p>
<h2 id="时基初始化结构体"><a href="#时基初始化结构体" class="headerlink" title="时基初始化结构体"></a>时基初始化结构体</h2><p><a href="https://imgchr.com/i/aEbF8s" target="_blank" rel="noopener"><img src="https://s1.ax1x.com/2020/07/28/aEbF8s.png" alt="时基初始化结构体"></a><br>由于基本定时器只能向上计数，所以计数模式不用配置。<br>外部时钟分频因子，基本定时器没有，所以也不用配置。<br>重复计数器是高级定时器专用，也不用配置。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">void TIMx_Config(void)</span><br><span class="line">&#123;</span><br><span class="line">	  TIM_TimeBaseInitTypeDef TIM_TimeBaseInitStruct;	</span><br><span class="line">	  RCC_APB1PeriphClockCmd(RCC_APB1Periph_TIM6,ENABLE);</span><br><span class="line">	  TIM_TimeBaseInitStruct.TIM_Prescaler = 71;//分频因子71，分频数为71+1=72，所以分频结束为1M</span><br><span class="line">	  TIM_TimeBaseInitStruct.TIM_Period = 3999; //中断周期从零计数到3999，计数4000次所以中断周期为1000*4/1000000=4ms</span><br><span class="line">	  TIM_TimeBaseInit(TIM6,&amp;TIM_TimeBaseInitStruct);//将配置好的数据写入到寄存器</span><br><span class="line">	  // 清除计数器中断标志位</span><br><span class="line">      TIM_ClearFlag(TIM6, TIM_FLAG_Update);</span><br><span class="line">	  // 开启计数器中断</span><br><span class="line">      TIM_ITConfig(TIM6,TIM_IT_Update,ENABLE);</span><br><span class="line">      // 使能计数器</span><br><span class="line">      TIM_Cmd(TIM6, ENABLE);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>基本定时器需要配置的结构体参数有:<br>TIM_Prescaler(预分频因子)，例程配置如下：<br>TIM_TimeBaseInitStruct.TIM_Prescaler = 71;<br>分频因子71，分频数为71+1=72，所以分频结束为1M<br>TIM_Period(自动重装载值)，通过调节这个调节中断周期，配置方法及计算方法如下：<br>TIM_TimeBaseInitStruct.TIM_Period = 3999;<br>中断周期从零计数到3999，计数4000次所以中断周期为1000*4/1000000=4ms</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="https://zwz522623.github.io.git/2020/07/28/%E5%9F%BA%E6%9C%AC%E5%AE%9A%E6%97%B6%E5%99%A8/" data-id="ckd5xazgp0000ukur4x5b7wmj" class="article-share-link">分享</a>
      
      
    </footer>
  </div>
  
</article>




  
    <article id="post-STM32 DMA读取多通道ADC" class="wow slideInRight article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2020/07/26/STM32%20DMA%E8%AF%BB%E5%8F%96%E5%A4%9A%E9%80%9A%E9%81%93ADC/" class="article-date">
  <time class="post-time" datetime="2020-07-26T11:28:18.315Z" itemprop="datePublished">
    <span class="post-month">7月</span><br/>
    <span class="post-day">26</span>
  </time>
</a>
   
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2020/07/26/STM32%20DMA%E8%AF%BB%E5%8F%96%E5%A4%9A%E9%80%9A%E9%81%93ADC/">STM32 DMA读取多通道ADC</a>
    </h1>
  

        <div>
          
          
              

          
        </div>
      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>由于ADC规则通道中只有一个寄存器，如果同时读取多个ADC<br>的数值会造成数据的覆盖，这个时候就需要用到DMA技术，将<br>读取到的ADC值暂存，等全部转换完成后再转换。</p>
<h2 id="DMA初始化结构体"><a href="#DMA初始化结构体" class="headerlink" title="DMA初始化结构体"></a>DMA初始化结构体</h2><p><img src="https://s1.ax1x.com/2020/07/26/aCPrK1.md.png" alt="DMA初始化结构体"><br>因为这次是选择通过DMA读取多路ADC1的值，所以复位控制器选择(ADC1对应DMA1<br>通道1，ADC3对应DMA3通道5，ADC2没有DMA功能)DMA1的通道1.外设基址选择DR寄<br>存器，储存器地址选择缓存的数组。数据源选择外设，缓冲区大小,应该等于数据目<br>的地的大小，这里和通道数一致。外设寄存器只有一个，地址不用递增，但是存储器<br>地址递增，外设数据与内存数据大小都为半字，即两个字节。传输模式选择循环传输。<br>DMA传输优先级为高，当使用一个DMA通道时，优先级设置不受影响，因为是从外设到<br>存储器，所以禁止储存器到储存器模式。初始化DMA后使能DMA通道，等待ADC的DMA请求。<br>需要注意的是DMA的时钟挂载的并不是APB2,而是AHB外设时钟。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">DMA_InitTypeDef  DMA_InitStruct;</span><br><span class="line">//打开dma时钟</span><br><span class="line">RCC_AHBPeriphClockCmd(ADC_DMA_CLK,ENABLE);</span><br><span class="line">//复位DMA控制器</span><br><span class="line">DMA_DeInit(ADC_DMA_CHANNEL);</span><br><span class="line">//初始化DMA初始化结构体</span><br><span class="line">   //外设基址为:ADC数据寄存器地址</span><br><span class="line">DMA_InitStruct.DMA_PeripheralBaseAddr = (u32)(&amp;(ADC_x-&gt;DR));</span><br><span class="line">   //存储器地址</span><br><span class="line">DMA_InitStruct.DMA_MemoryBaseAddr = (u32)ADC_ConvertedValue;</span><br><span class="line">//数据源来自外设</span><br><span class="line">DMA_InitStruct.DMA_DIR = DMA_DIR_PeripheralSRC;</span><br><span class="line">//缓冲区大小,应该等于数据目的地的大小</span><br><span class="line">DMA_InitStruct.DMA_BufferSize = NOFCHANEL;</span><br><span class="line">//外设寄存器只有一个，地址不用递增</span><br><span class="line">DMA_InitStruct.DMA_PeripheralInc = DMA_PeripheralInc_Disable;</span><br><span class="line">//存储器地址递增</span><br><span class="line">DMA_InitStruct.DMA_MemoryInc = DMA_MemoryInc_Enable;</span><br><span class="line">//外设数据大小为半字，即两个字节</span><br><span class="line">DMA_InitStruct.DMA_PeripheralDataSize = DMA_PeripheralDataSize_HalfWord;</span><br><span class="line">//内存大小数据也为半字，跟外设数据大小相同</span><br><span class="line">DMA_InitStruct.DMA_MemoryDataSize = DMA_MemoryDataSize_HalfWord;</span><br><span class="line">//循环传输模式</span><br><span class="line">DMA_InitStruct.DMA_Mode = DMA_Mode_Circular;</span><br><span class="line">//DMA传输优先级为高，当使用一个DMA通道时，优先级设置不受影响</span><br><span class="line">DMA_InitStruct.DMA_Priority = DMA_Priority_High;</span><br><span class="line">//禁止储存器到储存器模式，因为是从外设到储存器</span><br><span class="line">DMA_InitStruct.DMA_M2M = DMA_M2M_Disable;</span><br><span class="line">//初始化DMA</span><br><span class="line">DMA_Init(ADC_DMA_CHANNEL,&amp;DMA_InitStruct);</span><br><span class="line">//使能DMA通道</span><br><span class="line">DMA_Cmd(ADC_DMA_CHANNEL,ENABLE);</span><br></pre></td></tr></table></figure>
<h2 id="ADC初始化"><a href="#ADC初始化" class="headerlink" title="ADC初始化"></a>ADC初始化</h2><p>ADC的初始化与单个的ADC初始化大概一致，增加了ADC的DMA请求，并对ADC读取顺序做出了规定</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">//打开ADC时钟</span><br><span class="line">RCC_APB2PeriphClockCmd(RCC_APB2Periph_ADC1,ENABLE);</span><br><span class="line">//只使用1个ADC，属于单模式</span><br><span class="line">ADC_InitStruct.ADC_Mode = ADC_Mode_Independent;</span><br><span class="line">ADC_InitStruct.ADC_ScanConvMode = ENABLE;</span><br><span class="line">ADC_InitStruct.ADC_ContinuousConvMode = ENABLE;</span><br><span class="line">ADC_InitStruct.ADC_ExternalTrigConv = ADC_ExternalTrigConv_None;</span><br><span class="line">ADC_InitStruct.ADC_DataAlign = ADC_DataAlign_Right;</span><br><span class="line">ADC_InitStruct.ADC_NbrOfChannel = NOFCHANEL;</span><br><span class="line">ADC_Init(ADC_x,&amp;ADC_InitStruct);</span><br><span class="line">	</span><br><span class="line">RCC_ADCCLKConfig(RCC_PCLK2_Div8);</span><br><span class="line">ADC_RegularChannelConfig(ADC_x,ADC_Channel1,1,ADC_SampleTime_13Cycles5);</span><br><span class="line"> 	ADC_RegularChannelConfig(ADC_x,ADC_Channel2,2,ADC_SampleTime_13Cycles5);</span><br><span class="line"> 	ADC_RegularChannelConfig(ADC_x,ADC_Channel3,3,ADC_SampleTime_13Cycles5);</span><br><span class="line"> 	ADC_RegularChannelConfig(ADC_x,ADC_Channel4,4,ADC_SampleTime_13Cycles5);</span><br><span class="line"> 	ADC_RegularChannelConfig(ADC_x,ADC_Channel5,5,ADC_SampleTime_13Cycles5);</span><br><span class="line">ADC_RegularChannelConfig(ADC_x,ADC_Channel6,6,ADC_SampleTime_13Cycles5);</span><br><span class="line"></span><br><span class="line">//使能ADC DMA请求</span><br><span class="line">ADC_DMACmd(ADC_x,ENABLE);</span><br><span class="line">//开启ADC,并开始转换</span><br><span class="line">ADC_Cmd(ADC_x,ENABLE);</span><br><span class="line">//初始化ADC校准寄存器</span><br><span class="line">ADC_ResetCalibration(ADC_x);</span><br><span class="line">//等待校准寄存器初始化完成</span><br><span class="line"><span class="keyword">while</span>(ADC_GetResetCalibrationStatus(ADC_x));</span><br><span class="line">//ADC开始校准</span><br><span class="line">ADC_StartCalibration(ADC_x);</span><br><span class="line">//等待校准完成</span><br><span class="line"><span class="keyword">while</span>(ADC_GetCalibrationStatus(ADC_x));</span><br><span class="line">//由于没有使用外部触发，所以使用软件ADC触发</span><br><span class="line">ADC_SoftwareStartConvCmd(ADC_x,ENABLE);</span><br></pre></td></tr></table></figure>
<p>其中ADC_ConvertedValue[NOFCHANEL]为全局变量。DMA读取到ADC值后存到这个数组里。<br><img src="https://s1.ax1x.com/2020/07/26/aCkSEV.png" alt="ADC采样效果"></p>

      
    </div>
    <footer class="article-footer">
      <a data-url="https://zwz522623.github.io.git/2020/07/26/STM32%20DMA%E8%AF%BB%E5%8F%96%E5%A4%9A%E9%80%9A%E9%81%93ADC/" data-id="ckd30laps0000m4ur9zvs8pb2" class="article-share-link">分享</a>
      
      
    </footer>
  </div>
  
</article>




  
    <article id="post-stm32_ADC(独立模式单通道)" class="wow slideInRight article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2020/07/26/stm32_ADC(%E7%8B%AC%E7%AB%8B%E6%A8%A1%E5%BC%8F%E5%8D%95%E9%80%9A%E9%81%93)/" class="article-date">
  <time class="post-time" datetime="2020-07-26T06:34:21.677Z" itemprop="datePublished">
    <span class="post-month">7月</span><br/>
    <span class="post-day">26</span>
  </time>
</a>
   
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2020/07/26/stm32_ADC(%E7%8B%AC%E7%AB%8B%E6%A8%A1%E5%BC%8F%E5%8D%95%E9%80%9A%E9%81%93)/">STM32 ADC功能实现</a>
    </h1>
  

        <div>
          
          
              

          
        </div>
      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>STM32的外部16个通道分为规则通道和注入通道。注入通道最多有<br>四路。<br>这篇文章针对于stm32的独立模式单通道中断读取AD值。<br>编写ad采集程序分为以下几步：</p>
<h2 id="ADC初始化"><a href="#ADC初始化" class="headerlink" title="ADC初始化"></a>ADC初始化</h2><h3 id="初始化ADC用到的GPIO"><a href="#初始化ADC用到的GPIO" class="headerlink" title="初始化ADC用到的GPIO"></a>初始化ADC用到的GPIO</h3><p>初始化GPIO是使用ADC外设的时候不可缺少的一部分，通过芯片手册<br>上标注好的ADC引脚图选择ADC引脚并对其初始化。下图是ZET6的ADC<br>引脚分布：<br><img src="https://s1.ax1x.com/2020/07/26/a9tUKI.md.png" alt="ZET6ADC引脚分布"><br>这里我们初始化GPIO的代码就不再赘述，忘了的话可以翻阅一下前面<br>的文章。</p>
<h3 id="初始化ADC初始化结构体"><a href="#初始化ADC初始化结构体" class="headerlink" title="初始化ADC初始化结构体"></a>初始化ADC初始化结构体</h3><p>首先是初始化ADC时钟:ADC需要两个时钟，一个是外设时钟，另一个是采样时钟<br>第一步初始化的是ADC2的外设时钟：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">RCC_APB2PeriphClockCmd(RCC_APB2Periph_ADC2,ENABLE);</span><br></pre></td></tr></table></figure>
<p><img src="https://s1.ax1x.com/2020/07/26/a9KojS.png" alt="ADC初始化结构体"><br>之后是配置ADC工作模式,由于选用的是独立模式单通道，所以ADC工作参数具体<br>配置为：独立模式、单通道采集不需要扫描、启动连续转换、使用内部软件触发无<br>需外部触发事件、使用右对齐数据格式、转换通道为 1，并调用 ADC_Init函数完<br>成ADC工作环境配置。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">ADC_InitStruct.ADC_Mode = ADC_Mode_Independent;//独立模式</span><br><span class="line">ADC_InitStruct.ADC_ScanConvMode = DISABLE;//禁止扫描模式，多通道才需要扫描，单通道不需要</span><br><span class="line">ADC_InitStruct.ADC_ContinuousConvMode = ENABLE;//连续扫描模式</span><br><span class="line">ADC_InitStruct.ADC_ExternalTrigConv = ADC_ExternalTrigConv_None;//不用外部触发转换，软件开启即可</span><br><span class="line">ADC_InitStruct.ADC_DataAlign = ADC_DataAlign_Right;//转换结果右对齐</span><br><span class="line">ADC_InitStruct.ADC_NbrOfChannel = 1;//转换通道一个</span><br></pre></td></tr></table></figure>
<p>将配置好的结构体成员写到寄存器里面</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ADC_Init(ADC2,&amp;ADC_InitStruct);//初始化ADC</span><br></pre></td></tr></table></figure>
<p>RCC_ADCCLKConfig()函数用来配置 ADC 的工作时钟，接收一个参数，设置的是<br>PCLK2 的分频系数， ADC 的时钟最大不能超过 14M。<br>ADC_RegularChannelConfig 函数用来绑定 ADC 通道的转换顺序和采样时间。它接收 4<br>个形参，第一个形参选择 ADC 外设，可为 ADC1、 ADC2 或 ADC3；第二个形参通道选择，<br>总共可选 18 个通道；第三个形参为通道的转换顺序，可选为 1 到 16；第四个形参为采样<br>周期选择，采样周期越短， ADC 转换数据输出周期就越短但数据精度也越低，采样周期越<br>长，ADC转换数据输出周期就越长同时数据精度越高。<br>利用ADC转换完成中断可以非常方便的保证我们读取到的数据是转换完成后的数据<br>而不用担心该数据可能是 ADC 正在转换时“不稳定”的数据。我们使用ADC_ITConfig函<br>数使能ADC转换完成中断，并在中断服务函数中读取转换结果数据。<br>ADC_Cmd 函数控制ADC转换启动和停止。<br>最后，在ADC校准之后调用 ADC_SoftwareStartConvCmd 函数进行软件触发 ADC 开<br>始转换。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">      //配置ADC时钟为PCLK的8分频，即9MHZ</span><br><span class="line">RCC_ADCCLKConfig(RCC_PCLK2_Div8);</span><br><span class="line">//配置ADC通道转换顺序和采样时间</span><br><span class="line">ADC_RegularChannelConfig(ADCx,ADC_Channel_1,1,ADC_SampleTime_55Cycles5);</span><br><span class="line">   //adc转换结束产生中断，在中断服务函数中读取转换值</span><br><span class="line">ADC_ITConfig(ADCx,ADC_IT_EOC,ENABLE);</span><br><span class="line">//开启ADC并开始转换</span><br><span class="line">ADC_Cmd(ADCx,ENABLE);</span><br><span class="line">//初始化ADC,校准寄存器</span><br><span class="line">ADC_ResetCalibration(ADCx);</span><br><span class="line">//等待校准寄存器初始化完成</span><br><span class="line"><span class="keyword">while</span>(ADC_GetResetCalibrationStatus(ADCx));</span><br><span class="line">//adc开始校准</span><br><span class="line">ADC_StartCalibration(ADCx);</span><br><span class="line">//等待校准完成</span><br><span class="line"><span class="keyword">while</span>(ADC_GetCalibrationStatus(ADCx));</span><br><span class="line">//由于没有采用外部触发，所以使用软件触发ADC转换</span><br><span class="line">ADC_SoftwareStartConvCmd(ADCx,ENABLE);</span><br></pre></td></tr></table></figure>
<h3 id="ADC中断配置"><a href="#ADC中断配置" class="headerlink" title="ADC中断配置"></a>ADC中断配置</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">static void ADCx_NVIC_Config(void)</span><br><span class="line">&#123;</span><br><span class="line">		NVIC_InitTypeDef  NVIC_InitStruct;</span><br><span class="line">		//中断优先级分组</span><br><span class="line">		NVIC_PriorityGroupConfig(NVIC_PriorityGroup_1);</span><br><span class="line">		NVIC_InitStruct.NVIC_IRQChannel = ADC_IRQ;</span><br><span class="line">		NVIC_InitStruct.NVIC_IRQChannelPreemptionPriority = 1;</span><br><span class="line">	  NVIC_InitStruct.NVIC_IRQChannelSubPriority = 1;</span><br><span class="line">		NVIC_InitStruct.NVIC_IRQChannelCmd = ENABLE;</span><br><span class="line">		NVIC_Init(&amp;NVIC_InitStruct);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="ADC初始化-1"><a href="#ADC初始化-1" class="headerlink" title="ADC初始化"></a>ADC初始化</h2><p>配置完以上三步，ADC即可完成初始化最后通过ADCx_Init()函数使得初始化简易</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">void ADCx_Init(void)</span><br><span class="line">&#123;</span><br><span class="line">		ADCx_GPIO_Config();</span><br><span class="line">		ADCx_NVIC_Config();</span><br><span class="line">		ADCx_Mode_Config();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>之后只需要在主函数里面直接调用ADCx_Init();即可完成ADC的初始化。</p>
<h2 id="读取ADC"><a href="#读取ADC" class="headerlink" title="读取ADC"></a>读取ADC</h2><p>ADC完成转换之后会产生中断，我们只需要配置中断服务函数即可完成对<br>ADC的读取，读取完成后手动清除中断标志位。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">void ADC_IRQHandler(void)</span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">if</span>(ADC_GetITStatus(ADCx,ADC_IT_EOC)==SET)</span><br><span class="line">	&#123;</span><br><span class="line">		ADC_ConvertedValue = ADC_GetConversionValue(ADCx);</span><br><span class="line">	&#125;</span><br><span class="line">	ADC_ClearITPendingBit(ADCx,ADC_IT_EOC);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
      
    </div>
    <footer class="article-footer">
      <a data-url="https://zwz522623.github.io.git/2020/07/26/stm32_ADC(%E7%8B%AC%E7%AB%8B%E6%A8%A1%E5%BC%8F%E5%8D%95%E9%80%9A%E9%81%93)/" data-id="ckd2r07bn0000ewur38zi8gwx" class="article-share-link">分享</a>
      
      
    </footer>
  </div>
  
</article>




  
    <article id="post-EXTI初体验_(&#39;&#39;&#39;)" class="wow slideInRight article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2020/07/25/EXTI%E5%88%9D%E4%BD%93%E9%AA%8C_(''')/" class="article-date">
  <time class="post-time" datetime="2020-07-25T09:28:10.385Z" itemprop="datePublished">
    <span class="post-month">7月</span><br/>
    <span class="post-day">25</span>
  </time>
</a>
   
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2020/07/25/EXTI%E5%88%9D%E4%BD%93%E9%AA%8C_(''')/">EXTI外部中断/事件控制器</a>
    </h1>
  

        <div>
          
          
              

          
        </div>
      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h2 id="编程步骤"><a href="#编程步骤" class="headerlink" title="编程步骤"></a>编程步骤</h2><h3 id="初始化要连接到EXTI的GPIO"><a href="#初始化要连接到EXTI的GPIO" class="headerlink" title="初始化要连接到EXTI的GPIO"></a>初始化要连接到EXTI的GPIO</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">GPIO_InitTypeDef GPIO_InitStruct;</span><br><span class="line">//初始化要连接到EXTI的GPIO</span><br><span class="line">RCC_APB2PeriphClockCmd(Key1_Clock|Key2_Clock,ENABLE);</span><br><span class="line"></span><br><span class="line">GPIO_InitStruct.GPIO_Pin = Key1_Pin;</span><br><span class="line">GPIO_InitStruct.GPIO_Mode = GPIO_Mode_IN_FLOATING;</span><br><span class="line">GPIO_Init(Key1_Port,&amp;GPIO_InitStruct);</span><br><span class="line">GPIO_InitStruct.GPIO_Pin = Key2_Pin;</span><br><span class="line">GPIO_InitStruct.GPIO_Mode = GPIO_Mode_IN_FLOATING;</span><br><span class="line">GPIO_Init(Key2_Port,&amp;GPIO_InitStruct);</span><br></pre></td></tr></table></figure>
<h3 id="初始化EXTI用于产生中断-事件（记得使能AFIO时钟）"><a href="#初始化EXTI用于产生中断-事件（记得使能AFIO时钟）" class="headerlink" title="初始化EXTI用于产生中断/事件（记得使能AFIO时钟）"></a>初始化EXTI用于产生中断/事件（记得使能AFIO时钟）</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">   EXTI_InitTypeDef EXTI_InitStruct;</span><br><span class="line">   //初始化EXTI外设</span><br><span class="line">RCC_APB2PeriphClockCmd(RCC_APB2Periph_AFIO,ENABLE);//初始化AFIO时钟</span><br><span class="line">GPIO_EXTILineConfig(Key2_GPIO_PortSource,Key2_GPIO_PinSource); </span><br><span class="line">EXTI_InitStruct.EXTI_Line = Key2_EXTI;</span><br><span class="line">EXTI_InitStruct.EXTI_Mode = EXTI_Mode_Interrupt;</span><br><span class="line">EXTI_InitStruct.EXTI_Trigger = EXTI_Trigger_Rising;//上升沿触发</span><br><span class="line">EXTI_InitStruct.EXTI_LineCmd = ENABLE;</span><br><span class="line">EXTI_Init(&amp;EXTI_InitStruct);</span><br><span class="line">GPIO_EXTILineConfig(Key1_GPIO_PortSource,Key1_GPIO_PinSource); </span><br><span class="line">EXTI_InitStruct.EXTI_Line = Key1_EXTI;</span><br><span class="line">EXTI_InitStruct.EXTI_Mode = EXTI_Mode_Interrupt;</span><br><span class="line">EXTI_InitStruct.EXTI_Trigger = EXTI_Trigger_Falling;//下降沿触发</span><br><span class="line">EXTI_InitStruct.EXTI_LineCmd = ENABLE;</span><br><span class="line">EXTI_Init(&amp;EXTI_InitStruct);</span><br></pre></td></tr></table></figure>
<p>GPIO_EXTILineConfig函数是选择中断源的GPIO函数<br>EXTI_Line是选择输入线从EXTI_Line0到EXTI_Line19<br>EXTI_Mode有两个选择，一个是EXTI_Mode_Interrupt，另一个是EXTI_Mode_Event<br>EXTI_Trigger通过配置这个可以选择触发方式</p>
<h3 id="初始化NVIC用于处理中断"><a href="#初始化NVIC用于处理中断" class="headerlink" title="初始化NVIC用于处理中断"></a>初始化NVIC用于处理中断</h3><p>由于NVIC只需要调用一次，所以加上static，并在初始化EXTI时直接调用即可<br>系统框图如下<br><img src="https://s1.ax1x.com/2020/07/25/aSZDEV.png" alt="系统框图"><br>初始化NVIC分为以下几步：<br>第一步：<br>    通过NVIC_PriorityGroupConfig()函数配置中断优先级分组从0-4共五组<br>第二步：<br>    配置NVIC初始化结构体<br>    NVIC_InitStruct.NVIC_IRQChannel中断源，中断源在misc.h中有描述<br>    NVIC_InitStruct.NVIC_IRQChannelPreemptionPriority 主优先级<br>    NVIC_InitStruct.NVIC_IRQChannelSubPriority        子优先级<br>    NVIC_InitStruct.NVIC_IRQChannelCmd              使能或失能<br>第三步：<br>    调用NVIC初始化函数把配置好的结构体成员写到寄存器里面</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">static void NVIC_Config(void)    //全局，只需配置一次</span><br><span class="line">&#123;</span><br><span class="line">	NVIC_InitTypeDef NVIC_InitStruct;</span><br><span class="line">	//配置中断优先级分组</span><br><span class="line">	NVIC_PriorityGroupConfig(NVIC_PriorityGroup_1);</span><br><span class="line">	//配置NVIC初始化结构体</span><br><span class="line">	NVIC_InitStruct.NVIC_IRQChannel = Key2_NVIC_IRQChannel;</span><br><span class="line">	NVIC_InitStruct.NVIC_IRQChannelPreemptionPriority = 0;//主优先级</span><br><span class="line">	NVIC_InitStruct.NVIC_IRQChannelSubPriority = 0;//子优先级</span><br><span class="line">    NVIC_InitStruct.NVIC_IRQChannelCmd = ENABLE;</span><br><span class="line">	//调用NVIC初始化函数把配置好的结构体成员写到寄存器里面</span><br><span class="line">	NVIC_Init(&amp;NVIC_InitStruct);</span><br><span class="line">	</span><br><span class="line">	NVIC_InitStruct.NVIC_IRQChannel = Key1_NVIC_IRQChannel;</span><br><span class="line">	NVIC_InitStruct.NVIC_IRQChannelPreemptionPriority = 0;//主优先级</span><br><span class="line">	NVIC_InitStruct.NVIC_IRQChannelSubPriority = 1;//子优先级</span><br><span class="line">    NVIC_InitStruct.NVIC_IRQChannelCmd = ENABLE;	</span><br><span class="line">	</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>直到上面初始化就已经结束啦，下面附上完整的代码<br>exti.h</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#ifndef _EXTI_H</span></span><br><span class="line"><span class="comment">#define _EXTI_H</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#include "stm32f10x.h"</span></span><br><span class="line"><span class="comment">#include "core_cm3.h"</span></span><br><span class="line"><span class="comment">#include "misc.h"</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#define Key1_Clock            RCC_APB2Periph_GPIOC</span></span><br><span class="line"><span class="comment">#define Key1_Port             GPIOC</span></span><br><span class="line"><span class="comment">#define Key1_Pin              GPIO_Pin_13</span></span><br><span class="line"><span class="comment">#define Key1_GPIO_PortSource  GPIO_PortSourceGPIOC  </span></span><br><span class="line"><span class="comment">#define Key1_GPIO_PinSource   GPIO_PinSource13</span></span><br><span class="line"><span class="comment">#define Key1_EXTI             EXTI_Line13</span></span><br><span class="line"><span class="comment">#define Key1_NVIC_IRQChannel  EXTI15_10_IRQn</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#define Key2_Clock            RCC_APB2Periph_GPIOA</span></span><br><span class="line"><span class="comment">#define Key2_Port             GPIOA</span></span><br><span class="line"><span class="comment">#define Key2_Pin              GPIO_Pin_0</span></span><br><span class="line"><span class="comment">#define Key2_GPIO_PortSource  GPIO_PortSourceGPIOA</span></span><br><span class="line"><span class="comment">#define Key2_GPIO_PinSource   GPIO_PinSource0</span></span><br><span class="line"><span class="comment">#define Key2_EXTI             EXTI_Line0</span></span><br><span class="line"><span class="comment">#define Key2_NVIC_IRQChannel  EXTI0_IRQn</span></span><br><span class="line"></span><br><span class="line">static void NVIC_Config(void);</span><br><span class="line">void EXTI_Key_Config(void);</span><br><span class="line"><span class="comment">#endif</span></span><br></pre></td></tr></table></figure>
<p>exti.c</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#include "exti.h"    </span></span><br><span class="line"></span><br><span class="line">static void NVIC_Config(void)    //全局，只需配置一次</span><br><span class="line">&#123;</span><br><span class="line">	NVIC_InitTypeDef NVIC_InitStruct;</span><br><span class="line">	//配置中断优先级分组</span><br><span class="line">	NVIC_PriorityGroupConfig(NVIC_PriorityGroup_1);</span><br><span class="line">	//配置NVIC初始化结构体</span><br><span class="line">	NVIC_InitStruct.NVIC_IRQChannel = Key2_NVIC_IRQChannel;</span><br><span class="line">	NVIC_InitStruct.NVIC_IRQChannelPreemptionPriority = 0;//主优先级</span><br><span class="line">	NVIC_InitStruct.NVIC_IRQChannelSubPriority = 0;//子优先级</span><br><span class="line">  NVIC_InitStruct.NVIC_IRQChannelCmd = ENABLE;</span><br><span class="line">	//调用NVIC初始化函数把配置好的结构体成员写到寄存器里面</span><br><span class="line">	NVIC_Init(&amp;NVIC_InitStruct);</span><br><span class="line">	</span><br><span class="line">	NVIC_InitStruct.NVIC_IRQChannel = Key1_NVIC_IRQChannel;</span><br><span class="line">	NVIC_InitStruct.NVIC_IRQChannelPreemptionPriority = 0;//主优先级</span><br><span class="line">	NVIC_InitStruct.NVIC_IRQChannelSubPriority = 1;//子优先级</span><br><span class="line">  NVIC_InitStruct.NVIC_IRQChannelCmd = ENABLE;	</span><br><span class="line">	</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void EXTI_Key_Config()                                  </span><br><span class="line">&#123;</span><br><span class="line">	GPIO_InitTypeDef GPIO_InitStruct;</span><br><span class="line">	EXTI_InitTypeDef EXTI_InitStruct;</span><br><span class="line">	NVIC_Config();</span><br><span class="line">	//初始化要连接到EXTI的GPIO</span><br><span class="line">	RCC_APB2PeriphClockCmd(Key1_Clock|Key2_Clock,ENABLE);</span><br><span class="line">	</span><br><span class="line">	GPIO_InitStruct.GPIO_Pin = Key1_Pin;</span><br><span class="line">	GPIO_InitStruct.GPIO_Mode = GPIO_Mode_IN_FLOATING;</span><br><span class="line">	GPIO_Init(Key1_Port,&amp;GPIO_InitStruct);</span><br><span class="line">	GPIO_InitStruct.GPIO_Pin = Key2_Pin;</span><br><span class="line">	GPIO_InitStruct.GPIO_Mode = GPIO_Mode_IN_FLOATING;</span><br><span class="line">	GPIO_Init(Key2_Port,&amp;GPIO_InitStruct);</span><br><span class="line">  //初始化EXTI外设</span><br><span class="line">	RCC_APB2PeriphClockCmd(RCC_APB2Periph_AFIO,ENABLE);//初始化AFIO时钟</span><br><span class="line">	GPIO_EXTILineConfig(Key2_GPIO_PortSource,Key2_GPIO_PinSource); </span><br><span class="line">	EXTI_InitStruct.EXTI_Line = Key2_EXTI;</span><br><span class="line">	EXTI_InitStruct.EXTI_Mode = EXTI_Mode_Interrupt;</span><br><span class="line">	EXTI_InitStruct.EXTI_Trigger = EXTI_Trigger_Rising;//上升沿触发</span><br><span class="line">	EXTI_InitStruct.EXTI_LineCmd = ENABLE;</span><br><span class="line">	EXTI_Init(&amp;EXTI_InitStruct);</span><br><span class="line">	</span><br><span class="line">	GPIO_EXTILineConfig(Key1_GPIO_PortSource,Key1_GPIO_PinSource); </span><br><span class="line">	EXTI_InitStruct.EXTI_Line = Key1_EXTI;</span><br><span class="line">	EXTI_InitStruct.EXTI_Mode = EXTI_Mode_Interrupt;</span><br><span class="line">	EXTI_InitStruct.EXTI_Trigger = EXTI_Trigger_Falling;//下降沿触发</span><br><span class="line">	EXTI_InitStruct.EXTI_LineCmd = ENABLE;</span><br><span class="line">	EXTI_Init(&amp;EXTI_InitStruct);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>但是到目前为止，只是完成了初始化，还需要编写中断服务函数，中断服务函数的名字<br>为固定的，可以在misc.h处找到。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">void EXTI0_IRQHandler()</span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">if</span>((EXTI_GetITStatus(Key2_EXTI)) != RESET)</span><br><span class="line">	&#123;</span><br><span class="line">		int i;</span><br><span class="line">		i++;</span><br><span class="line">	&#125;</span><br><span class="line">	EXTI_ClearITPendingBit(Key2_EXTI);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void EXTI15_10_IRQHandler()</span><br><span class="line">&#123;</span><br><span class="line">		<span class="keyword">if</span>((EXTI_GetITStatus(Key1_EXTI)) != RESET)</span><br><span class="line">	&#123;</span><br><span class="line">		int i;</span><br><span class="line">		i++;</span><br><span class="line">	&#125;</span><br><span class="line">	EXTI_ClearITPendingBit(Key1_EXTI);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="最后一步"><a href="#最后一步" class="headerlink" title="最后一步"></a>最后一步</h3><p>在main函数里面调用初始化即可等待中断。</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="https://zwz522623.github.io.git/2020/07/25/EXTI%E5%88%9D%E4%BD%93%E9%AA%8C_(''')/" data-id="ckd1gl3jc0000okur0dbcfsbc" class="article-share-link">分享</a>
      
      
    </footer>
  </div>
  
</article>




  
    <article id="post-STM32中断概述" class="wow slideInRight article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2020/07/25/STM32%E4%B8%AD%E6%96%AD%E6%A6%82%E8%BF%B0/" class="article-date">
  <time class="post-time" datetime="2020-07-25T03:04:05.953Z" itemprop="datePublished">
    <span class="post-month">7月</span><br/>
    <span class="post-day">25</span>
  </time>
</a>
   
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2020/07/25/STM32%E4%B8%AD%E6%96%AD%E6%A6%82%E8%BF%B0/">STM32中断概述（不止于F103）</a>
    </h1>
  

        <div>
          
          
              

          
        </div>
      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h2 id="中断应用概念"><a href="#中断应用概念" class="headerlink" title="中断应用概念"></a>中断应用概念</h2><h3 id="中断类型"><a href="#中断类型" class="headerlink" title="中断类型"></a>中断类型</h3><p>系统中断：体现在内核水平<br>外部中断：体现在外设水平</p>
<h2 id="NVIC嵌套向量中断控制器"><a href="#NVIC嵌套向量中断控制器" class="headerlink" title="NVIC嵌套向量中断控制器"></a>NVIC嵌套向量中断控制器</h2><h3 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h3><p>NVIC:嵌套向量中断控制器，属于内核外设，管理着包括内核和片上所有<br>外设的相关功能。<br>两个重要的库文件：<br>                core_cm3.h  定义寄存器<br>                misc.h      定义相关函数</p>
<h3 id="中断优先级的定义"><a href="#中断优先级的定义" class="headerlink" title="中断优先级的定义"></a>中断优先级的定义</h3><h4 id="优先级的设定"><a href="#优先级的设定" class="headerlink" title="优先级的设定"></a>优先级的设定</h4><p>中断优先级由IPR寄存器设定：NVIC-&gt;IPRx<br>设定函数:</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">NVIC_SetPriority(IRQn_TypeIRQn,uint32_t priority);  //中断号，中断优先级</span><br></pre></td></tr></table></figure>

<h4 id="中断优先级的分组"><a href="#中断优先级的分组" class="headerlink" title="中断优先级的分组"></a>中断优先级的分组</h4><p>优先级分组                主优先级            子优先级<br>NVIC_PriorityGroup_0        0              0-15<br>NVIC_PriorityGroup_1        1              0-7<br>NVIC_PriorityGroup_2       0-3             0-3<br>NVIC_PriorityGroup_3       0-7             0-1<br>NVIC_PriorityGroup_4       0-15             0<br>设定函数：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">NVIC_PriorityGroupConfig(uint32_t NVIC_PriorityGroup);</span><br></pre></td></tr></table></figure>

<h3 id="中断编程顺序"><a href="#中断编程顺序" class="headerlink" title="中断编程顺序"></a>中断编程顺序</h3><pre><code>       使能中断请求
           |
           V
    配置中断优先级分组
           |
           V
配置NVIC寄存器，初始化NVIC_InitTypeDef;
           |
           V
     编写中断服务函数</code></pre><h4 id="使能中断请求"><a href="#使能中断请求" class="headerlink" title="使能中断请求"></a>使能中断请求</h4><p>该项具体到外设</p>
<h4 id="中断优先级分组"><a href="#中断优先级分组" class="headerlink" title="中断优先级分组"></a>中断优先级分组</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">NVIC_PriorityGroupConfig(uint32_t NVIC_PriorityGroup);</span><br></pre></td></tr></table></figure>
<h4 id="NVIC-InitTypeDef"><a href="#NVIC-InitTypeDef" class="headerlink" title="NVIC_InitTypeDef"></a>NVIC_InitTypeDef</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">NVIC_InitStruct.NVIC_IRQChannel:中断源</span><br><span class="line">NVIC_InitStruct.NVIC_IRQChannelPreemptionPriority：抢占优先级</span><br><span class="line">NVIC_InitStruct.NVIC_IRQChannelSubPriority：子优先级</span><br><span class="line">NVIC_InitStruct.NVIC_IRQChannelCmd：使能或失能</span><br><span class="line">NVIC_Init();</span><br></pre></td></tr></table></figure>

<h4 id="编写中断服务函数"><a href="#编写中断服务函数" class="headerlink" title="编写中断服务函数"></a>编写中断服务函数</h4><p>中断服务函数名称要与中断向量表中一至，否则进不去中断<br>stm32f10x_it.c默认放置中断服务函数，方便分配优先级</p>
<p><img src="https://image.baidu.com/search/detail?ct=503316480&z=undefined&tn=baiduimagedetail&ipn=d&word=%E5%A5%A5%E5%B0%94%E5%8A%A0%E4%B8%8D%E8%A6%81%E5%81%9C%E4%B8%8B%E6%9D%A5&step_word=&ie=utf-8&in=&cl=2&lm=-1&st=undefined&hd=undefined&latest=undefined&copyright=undefined&cs=1861462371,1849573485&os=2548686085,4258025421&simid=0,0&pn=1&rn=1&di=33020&ln=229&fr=&fmq=1595648989176_R&fm=&ic=undefined&s=undefined&se=&sme=&tab=0&width=undefined&height=undefined&face=undefined&is=0,0&istype=0&ist=&jit=&bdtype=10&spn=0&pi=0&gsm=0&objurl=http%3A%2F%2Ft7.baidu.com%2Fit%2Fu%3D2333738978%2C900919767%26fm%3D193&rpstart=0&rpnum=0&adpicid=0&force=undefined" alt="avatar"></p>

      
    </div>
    <footer class="article-footer">
      <a data-url="https://zwz522623.github.io.git/2020/07/25/STM32%E4%B8%AD%E6%96%AD%E6%A6%82%E8%BF%B0/" data-id="ckd148kdm000038urcm6t5wx4" class="article-share-link">分享</a>
      
      
    </footer>
  </div>
  
</article>




  
    <article id="post-stm32读取按键" class="wow slideInRight article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2020/07/24/stm32%E8%AF%BB%E5%8F%96%E6%8C%89%E9%94%AE/" class="article-date">
  <time class="post-time" datetime="2020-07-24T11:53:05.533Z" itemprop="datePublished">
    <span class="post-month">7月</span><br/>
    <span class="post-day">24</span>
  </time>
</a>
   
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2020/07/24/stm32%E8%AF%BB%E5%8F%96%E6%8C%89%E9%94%AE/">STM32读取按键</a>
    </h1>
  

        <div>
          
          
              

          
        </div>
      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>之前已经通过点灯的方式实现了对GPIO写入的操作，今天要做的便是读取<br>GPIO引脚的状态，引脚电平通过TTL肖特基触发器，大于1.8V的输出为1，<br>低于1.8v的输出为0，加载到ODR寄存器中，通过读取寄存器的值便可以读<br>出引脚的状态。</p>
<h2 id="读取按键"><a href="#读取按键" class="headerlink" title="读取按键"></a>读取按键</h2><h2 id="第一步：初始化GPIO"><a href="#第一步：初始化GPIO" class="headerlink" title="第一步：初始化GPIO"></a>第一步：初始化GPIO</h2><h3 id="宏定义引脚，增加可读性"><a href="#宏定义引脚，增加可读性" class="headerlink" title="宏定义引脚，增加可读性"></a>宏定义引脚，增加可读性</h3><p>为了使程序更加的清晰，同时也是为了增加程序的可移植性，在程序里面<br>关于引脚的定义选择宏定义，具体操作如下：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#define Key1_GPIO_CLK   RCC_APB2Periph_GPIOC</span></span><br><span class="line"><span class="comment">#define Key1_GPIO_Port  GPIOC</span></span><br><span class="line"><span class="comment">#define Key1_GPIO_Pin   GPIO_Pin_13</span></span><br></pre></td></tr></table></figure>
<p>宏定义将RCC_APB2Periph_GPIOC替换为了Key1_GPIO_CLK，这样在程序<br>里面就可以清楚地看到初始化的是哪一个外设的时钟，程序的可读性也大<br>大的提高了。</p>
<h3 id="初始化GPIO"><a href="#初始化GPIO" class="headerlink" title="初始化GPIO"></a>初始化GPIO</h3><p>初始化GPIO的操作与之前点灯时候的操作大体一致，不过由于按键是输入，<br>所以GPIO_SPEED可以不去配置，初始化代码如下:</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">void Key_Init()</span><br><span class="line">&#123;</span><br><span class="line">	GPIO_InitTypeDef GPIO_InitTStruct;</span><br><span class="line">	//KEY1,KEY2引脚时钟使能</span><br><span class="line">	RCC_APB2PeriphClockCmd(Key1_GPIO_CLK|Key2_GPIO_CLK,ENABLE);//宏定义用Key1_GPIO_CLK代替RCC_APB2Periph_GPIOC</span><br><span class="line">	</span><br><span class="line">	//初始化key1引脚</span><br><span class="line">	GPIO_InitTStruct.GPIO_Pin = Key1_GPIO_Pin;</span><br><span class="line">	GPIO_InitTStruct.GPIO_Mode = GPIO_Mode_IN_FLOATING;</span><br><span class="line">	//GPIO_InitTStruct.GPIO_Speed = GPIO_Speed_10MHz;输出时需要配置速度</span><br><span class="line">	GPIO_Init(Key1_GPIO_Port,&amp;GPIO_InitTStruct);</span><br><span class="line">	</span><br><span class="line">	//初始化key2引脚</span><br><span class="line">	GPIO_InitTStruct.GPIO_Pin = Key2_GPIO_Pin;</span><br><span class="line">	GPIO_InitTStruct.GPIO_Mode = GPIO_Mode_IN_FLOATING;</span><br><span class="line">	GPIO_Init(Key2_GPIO_Port,&amp;GPIO_InitTStruct);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>按键为输入部分，所以引脚模式（GPIO_Mode）设置为浮空输入（GPIO_Mode_IN_FLOATING）。</p>
<h3 id="按键检测"><a href="#按键检测" class="headerlink" title="按键检测"></a>按键检测</h3><p>通过上面的步骤我们已经初始化好了GPIO所需要的的引脚，接下来要做的便是<br>读取到ODR寄存器里面的值，由于库函数已经写好了读取的函数，我们直接调<br>用即可：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">GPIO_ReadInputDataBit(GPIOx,GPIO_Pin)；//这是只读取一个引脚状态的函数</span><br><span class="line">GPIO_ReadInputData(GPIOx);             //读取这个端口里所有的引脚的值</span><br></pre></td></tr></table></figure>
<p>按键检测函数：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">uint16_t Keyscan(GPIO_TypeDef* GPIOx,uint16_t GPIO_Pin)  //按键扫描函数</span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">if</span>(GPIO_ReadInputDataBit(GPIOx,GPIO_Pin))</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">while</span>(GPIO_ReadInputDataBit(GPIOx,GPIO_Pin)==Key_On);//松手检测</span><br><span class="line">		<span class="built_in">return</span> Key_On;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">else</span></span><br><span class="line">	 <span class="built_in">return</span> Key_Off;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>按键检测这就差不多结束了，之后只需要调用Keyscan()这个函数即可，具体<br>功能可以自行决定。</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="https://zwz522623.github.io.git/2020/07/24/stm32%E8%AF%BB%E5%8F%96%E6%8C%89%E9%94%AE/" data-id="ckd0yk46x0000scur1gt30oxt" class="article-share-link">分享</a>
      
      
    </footer>
  </div>
  
</article>




  
    <article id="post-stm32入门" class="wow slideInRight article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2020/07/24/stm32%E5%85%A5%E9%97%A8/" class="article-date">
  <time class="post-time" datetime="2020-07-24T08:30:20.628Z" itemprop="datePublished">
    <span class="post-month">7月</span><br/>
    <span class="post-day">24</span>
  </time>
</a>
   
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2020/07/24/stm32%E5%85%A5%E9%97%A8/">stm32入门</a>
    </h1>
  

        <div>
          
          
              

          
        </div>
      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <hr>
<p>title: STM32入门笔记（1）</p>
<p> stm32库函数已经十分完善，学习stm32可以从寄存器开始，这种方法虽然可以<br> 有个很好的理解，但是入门过难，所以我选择了相较与简单的库函数入手学习stm<br> 32这款单片机。</p>
<p>##第一步：（<del>万物基于点灯</del>）<br>点灯其实就是对单片机的管脚口进行操作，控制引脚的高低电平。stm32相较于<br>之前的单片机增加了对引脚的初始化的步骤。<br>    首先是在头文件中添加外设相关的库函数:’stm32f10x.h’<br>    其次是声明结构体变量：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">GPIO_InitTypeDef GPIO_InitStruct;</span><br></pre></td></tr></table></figure>
<p>之后便是使能外设的时钟，时钟由RCC的外设控制，具体内容可以在rcc的头文件<br>中看到，由文档描述可知，所有的GPIO都挂载在APB2总线上，所以选择使能APB2的时<br>钟。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$    RCC_APB2PeriphClockCmd(RCC_APB2Periph_GPIOC,ENABLE);//使能GPIOC的时钟，ENABLE--使能，DISABLE--不使能</span><br></pre></td></tr></table></figure>
<p>下一步便是配置外设初始化结构体，一般名称为:XXXX_InitTypeDef<br>具体顺序为:选择引脚-&gt;选择输出模式-&gt;选择速度</p>
<pre><code class="bash">GPIO_InitStruct.GPIO_Pin = GPIO_Pin_2;             //2号引脚
GPIO_InitStruct.GPIO_Mode = GPIO_Mode_Out_PP;      //PP:推挽输出
GPIO_InitStruct.GPIO_Speed = GPIO_Speed_10MHz;     //速度选择10MHZ</code></pre>
<p>最后一步便是调用外设初始化函数，把配置好的结构体变量写到寄存器里</p>
<pre><code class="bash">GPIO_Init(GPIOC,&amp;GPIO_InitStruct);//由于GPIO_InitStruct为变量，但是函数传入的为指针，所以对变量取地址，输入即为变量</code></pre>
<p>直到上面，引脚的初始化就结束了。之后便是对引脚进行操作。</p>
<pre><code class="bash">GPIO_SetBits(GPIOC,GPIO_Pin_2);//置位
GPIO_ResetBits(GPIOC,GPIO_Pin_2);//复位，输出低</code></pre>
<p>最后附上完整代码:</p>
<pre><code class="bash">void Led_GPIO_Config(void)
{
  GPIO_InitTypeDef GPIO_InitStruct;
  //使能时钟
  RCC_APB2PeriphClockCmd(RCC_APB2Periph_GPIOC,ENABLE);
  //配置外设初始化结构体
  GPIO_InitStruct.GPIO_Pin = GPIO_Pin_2;
  GPIO_InitStruct.GPIO_Mode = GPIO_Mode_Out_PP;
  GPIO_InitStruct.GPIO_Speed = GPIO_Speed_10MHz;
  //调用外设初始化函数，将初始化好的结构体变量写到寄存器里面
  GPIO_Init(GPIOC,&amp;GPIO_InitStruct);
}</code></pre>
<pre><code class="bash">int main(void)
{
  // 来到这里的时候，系统的时钟已经被配置成72M。
  Led_GPIO_Config();
  <span class="keyword">while</span>(1)
  {
    GPIO_SetBits(GPIOC,GPIO_Pin_2);//置位
    delay(500);
    GPIO_ResetBits(GPIOC,GPIO_Pin_2);//复位，输出低
  }
}</code></pre>

      
    </div>
    <footer class="article-footer">
      <a data-url="https://zwz522623.github.io.git/2020/07/24/stm32%E5%85%A5%E9%97%A8/" data-id="ckczz8dd50000nkurhjheay17" class="article-share-link">分享</a>
      
      
    </footer>
  </div>
  
</article>




  
    <article id="post-自制全志H3linux卡片电脑" class="wow slideInRight article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2020/06/01/%E8%87%AA%E5%88%B6%E5%85%A8%E5%BF%97H3linux%E5%8D%A1%E7%89%87%E7%94%B5%E8%84%91/" class="article-date">
  <time class="post-time" datetime="2020-06-01T07:21:10.081Z" itemprop="datePublished">
    <span class="post-month">6月</span><br/>
    <span class="post-day">01</span>
  </time>
</a>
   
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2020/06/01/%E8%87%AA%E5%88%B6%E5%85%A8%E5%BF%97H3linux%E5%8D%A1%E7%89%87%E7%94%B5%E8%84%91/">Hello Linux</a>
    </h1>
  

        <div>
          
          
              

          
        </div>
      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h2 id="挖坑原因"><a href="#挖坑原因" class="headerlink" title="挖坑原因"></a>挖坑原因</h2><pre><code>之前也玩过各种各样的pi，什么树莓派，荔枝派，jestonnano。
玩着玩着感觉这个东西虽然说是好用，但毕竟不是自己做出来的
东西。尤其是树莓派，使用的是博通的一款arm芯片，说是开源的，
但实际上只有管脚口的定义，并没有真正意义上的开源。加上前几
天稚辉大佬做的一款linux卡片电脑，做的十分小巧。就激发了我
也做一款属于自己的卡片电脑的想法。</code></pre><h2 id="难点"><a href="#难点" class="headerlink" title="难点"></a>难点</h2><pre><code>这个项目的主要难点便是ddr3的走线。由于之前设计的电路频率
一般都不高，几乎是走通就可以用的那种。但是由于ddr3是高速
并行信号线。要做好信号线的等长处理，ddr3中还有差分信号对。
所以还要学会走差分信号线。另一个最主要的点便是如何在把板
子做的足够小的同时还能减少板子的层数。四层板由于嘉立创目
前打折5cm*5cm的只需要30块钱，所以优先考虑四层板。六层板
打样价格飞起，暂不考虑。</code></pre><h2 id="ddr3走线注意事项"><a href="#ddr3走线注意事项" class="headerlink" title="ddr3走线注意事项"></a>ddr3走线注意事项</h2><pre><code>(1) 支持DDR3，LPDDR2LPDDR3，使用时需先确定DRAM的类型，
以及单片的位宽。
(2) 主控和DRAM端每一个ZQ PIN都必须接240R-1%精度的下
拉到地电阻。
(3) SDQ0-SDQ7，SDQ8-SDQ15，SDQ16-SDQ23，SDQ24-SDQ31
分别为4组数据线， 若用DDR 3， 则可以进行组内或者组间交换，
若进行组间交换，则相应的SDQM和SDQS差分对也必须对应交换。
(4)若用LPDDR2或者LPDDR3，则SDQ0-SDQ7，SDQM0，SDQ0，SDQS0B
必须与主控一一对应连接，而其他高位的3组DQ以及高位的DQM和DQS差分对
，则与DDR3类似，可以进行组内组间交换。</code></pre><h2 id="未完待续"><a href="#未完待续" class="headerlink" title="未完待续"></a>未完待续</h2>
      
    </div>
    <footer class="article-footer">
      <a data-url="https://zwz522623.github.io.git/2020/06/01/%E8%87%AA%E5%88%B6%E5%85%A8%E5%BF%97H3linux%E5%8D%A1%E7%89%87%E7%94%B5%E8%84%91/" data-id="ckaw78x8x0000xgur6vt6gzcx" class="article-share-link">分享</a>
      
      
    </footer>
  </div>
  
</article>




  
    <article id="post-Markdown语法" class="wow slideInRight article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2020/05/31/Markdown%E8%AF%AD%E6%B3%95/" class="article-date">
  <time class="post-time" datetime="2020-05-30T23:46:42.162Z" itemprop="datePublished">
    <span class="post-month">5月</span><br/>
    <span class="post-day">31</span>
  </time>
</a>
   
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2020/05/31/Markdown%E8%AF%AD%E6%B3%95/">Hello MarkDown</a>
    </h1>
  

        <div>
          
          
              

          
        </div>
      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h2 id="基础的语句介绍"><a href="#基础的语句介绍" class="headerlink" title="基础的语句介绍"></a>基础的语句介绍</h2><h3 id="简易的分支语句"><a href="#简易的分支语句" class="headerlink" title="简易的分支语句"></a>简易的分支语句</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">##代表着第一层###代表着第一层的分支####代表着下一层的分支，合理利用就能更方便的在想要查找的时候更加方便</span></span><br></pre></td></tr></table></figure>
<h4 id="第三层"><a href="#第三层" class="headerlink" title="第三层"></a>第三层</h4><h5 id="第五层"><a href="#第五层" class="headerlink" title="第五层"></a>第五层</h5><h3 id="如何放置程序段"><a href="#如何放置程序段" class="headerlink" title="如何放置程序段"></a>如何放置程序段</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">效果如下：</span><br><span class="line">&#96;&#96;&#96; bash</span><br><span class="line">效果展示</span><br></pre></td></tr></table></figure>

<p>###如何加入超链接<br>More Info: + [自定义的按键名] +（想要放置的链接）<br>效果如下：<br>More Info: <a href="chrome://dino">点击即玩</a></p>
<h2 id="花里胡哨的用法"><a href="#花里胡哨的用法" class="headerlink" title="花里胡哨的用法"></a>花里胡哨的用法</h2><p>（<del>没有</del>）</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="https://zwz522623.github.io.git/2020/05/31/Markdown%E8%AF%AD%E6%B3%95/" data-id="ckauav4oc0000h8ur8y3v7vkc" class="article-share-link">分享</a>
      
      
    </footer>
  </div>
  
</article>




  
    <article id="post-第一篇个人博客" class="wow slideInRight article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2020/05/30/%E7%AC%AC%E4%B8%80%E7%AF%87%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2/" class="article-date">
  <time class="post-time" datetime="2020-05-30T11:39:52.778Z" itemprop="datePublished">
    <span class="post-month">5月</span><br/>
    <span class="post-day">30</span>
  </time>
</a>
   
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2020/05/30/%E7%AC%AC%E4%B8%80%E7%AF%87%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2/">百度人工智能AIP的调用</a>
    </h1>
  

        <div>
          
          
              

          
        </div>
      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><p>首先进入百度人工智能的官网主页并选择控制台<br>点击链接:<a href="https://ai.baidu.com/?track=cp:aipinzhuan|pf:pc|pp:AIpingtai|pu:title|ci:|kw:10005792" target="_blank" rel="noopener">主页</a><br>以文字识别为例，点击创建应用。应用名和描述按照自己需求自行决定。没有特殊需求的也可以随便打打（<del>不是</del>），创建完成之后点击下载sdk。由于我是用的python语言，所以选择python的sdk。点击帮助文档。</p>
<h2 id="安装环境"><a href="#安装环境" class="headerlink" title="安装环境"></a>安装环境</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ pip install baidu-aip %% 已安装pip</span><br></pre></td></tr></table></figure>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ python setup.py install %% 已安装setuptools</span><br></pre></td></tr></table></figure>
<h2 id="新建AipOcr"><a href="#新建AipOcr" class="headerlink" title="新建AipOcr"></a>新建AipOcr</h2><p>AipOcr是Ocr的python sdk客户端，为使用其的开发人员提供了一系列的交互方法。<br>其中的APPID，Aip Key，Secret Key这三项参数要填自己的参数。这三项均可在控制台中的管理应用里找到</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">from aip import AipOcr</span><br><span class="line"></span><br><span class="line"><span class="string">""</span><span class="string">" 你的 APPID AK SK "</span><span class="string">""</span></span><br><span class="line">APP_ID = <span class="string">'你的 App ID'</span></span><br><span class="line">API_KEY = <span class="string">'你的 Api Key'</span></span><br><span class="line">SECRET_KEY = <span class="string">'你的 Secret Key'</span></span><br><span class="line"></span><br><span class="line">client = AipOcr(APP_ID, API_KEY, SECRET_KEY)</span><br></pre></td></tr></table></figure>

<h3 id="AIP的调用"><a href="#AIP的调用" class="headerlink" title="AIP的调用"></a>AIP的调用</h3><p>读取的本地图片需要更改image = get_file_content(),将括号里的元素改成需要识别的图片的存储路径即可。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">""</span><span class="string">" 读取图片 "</span><span class="string">""</span></span><br><span class="line">def get_file_content(filePath):</span><br><span class="line">    with open(filePath, <span class="string">'rb'</span>) as fp:</span><br><span class="line">        <span class="built_in">return</span> fp.read()</span><br><span class="line"></span><br><span class="line">image = get_file_content(<span class="string">'example.jpg'</span>)</span><br><span class="line"></span><br><span class="line"><span class="string">""</span><span class="string">" 调用通用文字识别, 图片参数为本地图片 "</span><span class="string">""</span></span><br><span class="line">client.basicGeneral(image);</span><br><span class="line"></span><br><span class="line"><span class="string">""</span><span class="string">" 如果有可选参数 "</span><span class="string">""</span></span><br><span class="line">options = &#123;&#125;</span><br><span class="line">options[<span class="string">"language_type"</span>] = <span class="string">"CHN_ENG"</span></span><br><span class="line">options[<span class="string">"detect_direction"</span>] = <span class="string">"true"</span></span><br><span class="line">options[<span class="string">"detect_language"</span>] = <span class="string">"true"</span></span><br><span class="line">options[<span class="string">"probability"</span>] = <span class="string">"true"</span></span><br><span class="line"><span class="string">""</span><span class="string">" 带参数调用通用文字识别, 图片参数为本地图片 "</span><span class="string">""</span></span><br><span class="line">client.basicGeneral(image, options)</span><br></pre></td></tr></table></figure>
<h2 id="调用结束"><a href="#调用结束" class="headerlink" title="调用结束"></a>调用结束</h2><p>到上面一步调用就已经完成，但是为了方便debug。最好还是打印一下输出</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">a = client.basicGeneral(image, options)</span><br><span class="line"><span class="built_in">print</span>(a)</span><br></pre></td></tr></table></figure>
<h2 id="注意事项（血泪踩坑史）"><a href="#注意事项（血泪踩坑史）" class="headerlink" title="注意事项（血泪踩坑史）"></a>注意事项（<del>血泪踩坑史</del>）</h2><p>百度人工智能的识别速度由于是在云端计算的，电脑本身的性能和识别速度并无关系。但是，百度看似给了5000或50000的使用裕量。如果进入个死循环的话不一会儿就会使用光了。所以不要以为那个数字很多，其实很快就会使用光的。用光的话就会走你充值的账户余额了，或者干脆停止服务。</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="https://zwz522623.github.io.git/2020/05/30/%E7%AC%AC%E4%B8%80%E7%AF%87%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2/" data-id="ckatlnhxw0000dsur4xgz3cg5" class="article-share-link">分享</a>
      
      
    </footer>
  </div>
  
</article>




  


  <nav id="page-nav">
    <span class="page-number current">1</span><a class="page-number" href="/page/2/">2</a><a class="extend next" rel="next" href="/page/2/">next &amp;raquo;</a>
  </nav>
</section>
        
          <aside id="sidebar">
  
    <div class="widget-wrap">
  <h3 class="widget-title"></h3>
  <div class="widget">
    <h1 class="blog-title">张维尊的博客</h1>
    <h2 class="blog-subtitle"></h2>
    <ul class="blog-link">
     
          <a href="/" title="Home">
            <li>主页</li>
          </a>
        
          <a href="/archives" title="Archives">
            <li>归档</li>
          </a>
        
          <a href="/categories" title="Categories">
            <li>分类</li>
          </a>
        
          <a href="/tags" title="Tags">
            <li>标签</li>
          </a>
        
    </ul>
  </div>
</div>

  
    <div class="widget-wrap">
  <h3 class="widget-title"></h3>
  <div class="widget">
    <img class="avatar" src="https://avatars0.githubusercontent.com/u/20333903?v=3&amp;s=460">
    <h2 class="author">ZWZ</h2>
    <h3 class="description">纸上得来终觉浅，绝知此事要躬行</h3>
    <div class="count-box">
      <a href="/archives"><div><strong>11</strong><br>文章</div></a>
      <a href="/categories"><div><strong>0</strong><br>分类</div></a>
      <a href="/tags"><div><strong>0</strong><br>标签</div></a>
    </div>



    <div class="social-link">
      
        <a class="hvr-bounce-in" href="http://github.com/ShanaMaid" target="_blank" title="Github">
          Github
        </a>
      
    </div>

    <div class="friend-link">
      <h2>友情链接</h2>
      
        <a class="hvr-bounce-in" href="http://blog.shanamaid.top/" target="_blank" title="ShanaMaid">
          ShanaMaid
        </a>
      
    </div>
  </div>
</div>

  
</aside>
        
      </div>
      <footer id="footer">
  
  <div class="outer">
    <div id="footer-info" class="inner">
      &copy;2019 - 2020 ZWZ<br>
      由<a href="http://hexo.io/" target="_blank">Hexo</a>强力驱动 | 
      主题-<a href="https://github.com/ShanaMaid/hexo-theme-shana" target="_blank" rel="noopener">Shana</a>
      
    </div>
    
  </div>
</footer>
    </div>
    

<script src="//apps.bdimg.com/libs/jquery/2.1.4/jquery.min.js"></script>
<script src="//apps.bdimg.com/libs/wow/0.1.6/wow.min.js"></script>
<script>
new WOW().init();
</script>   


  
<link rel="stylesheet" href="/plugin/fancybox/jquery.fancybox.css">

  
<script src="/plugin/fancybox/jquery.fancybox.pack.js"></script>




  
<link rel="stylesheet" href="/plugin/galmenu/GalMenu.css">

  
<script src="/plugin/galmenu/GalMenu.js"></script>

  <div class="GalMenu GalDropDown">
      <div class="circle" id="gal">
        <div class="ring">
          
            <a href="/" title="" class="menuItem">首页</a>
          
            <a href="/tags" title="" class="menuItem">标签</a>
          
            <a href="/categories" title="" class="menuItem">分类</a>
          
            <a href="/archives" title="" class="menuItem">归档</a>
          
            <a href="/xxxxxxxxx" title="" class="menuItem">xxx</a>
          
            <a href="/xxxxxxx" title="" class="menuItem">xxxx</a>
          
        </div>
        
          <audio id="audio" src="#"></audio>
        
      </div> 
</div>
<div id="overlay" style="opacity: 1; cursor: pointer;"></div>
  <script type="text/javascript">var items = document.querySelectorAll('.menuItem');
    for (var i = 0,
    l = items.length; i < l; i++) {
      items[i].style.left = (50 - 35 * Math.cos( - 0.5 * Math.PI - 2 * (1 / l) * i * Math.PI)).toFixed(4) + "%";
      items[i].style.top = (50 + 35 * Math.sin( - 0.5 * Math.PI - 2 * (1 / l) * i * Math.PI)).toFixed(4) + "%"
    }</script>
<script type="text/javascript">
  $(document).ready(function() {
    $('body').GalMenu({
      'menu': 'GalDropDown'
    })
  });
</script>

  <section class="hidden-xs"> 
  <ul class="cb-slideshow"> 
    <li><span>苟利</span></li> 
    <li><span>国家</span></li> 
    <li><span>生死以</span></li> 
    <li><span>岂能</span></li> 
    <li><span>祸福</span></li> 
    <li><span>趋避之</span></li> 
  </ul>
</section>

<script src="/js/script.js"></script>




  </div>
<script src="/live2dw/lib/L2Dwidget.min.js?094cbace49a39548bed64abff5988b05"></script><script>L2Dwidget.init({"log":false,"pluginJsPath":"lib/","pluginModelPath":"assets/","pluginRootPath":"live2dw/","tagMode":false});</script></body>
</html>
<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  
  <title>张维尊的博客</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  <meta name="description" content="我们生活的每个日常，都是连续发生的奇迹">
<meta property="og:type" content="website">
<meta property="og:title" content="张维尊的博客">
<meta property="og:url" content="https://zwz522623.github.io.git/index.html">
<meta property="og:site_name" content="张维尊的博客">
<meta property="og:description" content="我们生活的每个日常，都是连续发生的奇迹">
<meta property="og:locale" content="zh_CN">
<meta property="article:author" content="尊某">
<meta name="twitter:card" content="summary">
  
    <link rel="alternate" href="/atom.xml" title="张维尊的博客" type="application/atom+xml">
  
  
    <link rel="icon" href="/favicon.png">
  
  
    <link href="//fonts.googleapis.com/css?family=Source+Code+Pro" rel="stylesheet" type="text/css">
  
  
<link rel="stylesheet" href="/css/style.css">

  
<link rel="stylesheet" href="/plugin/bganimation/bg.css">

  

  <link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.10.0/katex.min.css" rel="stylesheet" type="text/css">
<meta name="generator" content="Hexo 4.2.1"></head>

<body>
  <div id="container">
    <div id="wrap">
      <div class="outer">
        <div class="widget-wrap mobile-header">
  <h3 class="widget-title"></h3>
  <div class="widget">
    <img class="avatar" src="https://avatars0.githubusercontent.com/u/20333903?v=3&amp;s=460">
    <h2 class="author">尊某</h2>
    <h3 class="description">我们生活的每个日常，都是连续发生的奇迹</h3>
    <div class="count-box">
      <a href="/archives"><div><strong>14</strong><br>文章</div></a>
      <a href="/categories"><div><strong>0</strong><br>分类</div></a>
      <a href="/tags"><div><strong>0</strong><br>标签</div></a>
    </div>
    <ul class="blog-link">
     
          <a href="/" title="Home">
            <li>主页</li>
          </a>
        
          <a href="/archives" title="Archives">
            <li>归档</li>
          </a>
        
          <a href="/categories" title="Categories">
            <li>分类</li>
          </a>
        
          <a href="/tags" title="Tags">
            <li>标签</li>
          </a>
        
    </ul>
  </div>
</div>

        <section id="main">
  
    <article id="post-软件模拟IIC" class="wow slideInRight article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2020/08/01/%E8%BD%AF%E4%BB%B6%E6%A8%A1%E6%8B%9FIIC/" class="article-date">
  <time class="post-time" datetime="2020-08-01T11:23:12.111Z" itemprop="datePublished">
    <span class="post-month">8月</span><br/>
    <span class="post-day">01</span>
  </time>
</a>
   
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2020/08/01/%E8%BD%AF%E4%BB%B6%E6%A8%A1%E6%8B%9FIIC/">软件模拟IIC</a>
    </h1>
  

        <div>
          
          
              

          
        </div>
      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>STM32自带硬件iic，但是由于引脚固定，使用起来不是很灵活，因此<br>选择了软件模拟iic。</p>
<h2 id="IIC起始信号"><a href="#IIC起始信号" class="headerlink" title="IIC起始信号"></a>IIC起始信号</h2><p>IIC的起始信号是在scl为高电平的时候，sda产生一个下降沿为IIC起始信号</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">void i2c_Start(void)</span><br><span class="line">&#123;</span><br><span class="line">	/* 当SCL高电平时，SDA出现一个下跳沿表示I2C总线启动信号 */</span><br><span class="line">	I2C_SDA_1();      //先把两条线同时拉高做准备</span><br><span class="line">	I2C_SCL_1();</span><br><span class="line">	i2c_Delay();</span><br><span class="line">	I2C_SDA_0();     //延时一段时间后将sda拉低并保持延时一段时间</span><br><span class="line">	i2c_Delay();</span><br><span class="line">	</span><br><span class="line">	I2C_SCL_0();     //将时钟线拉低，准备数据的传输，IIC数据为在时钟线为高时有效</span><br><span class="line">	i2c_Delay();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">static void i2c_Delay(void)</span><br><span class="line">&#123;</span><br><span class="line">	uint8_t i;</span><br><span class="line"></span><br><span class="line">	/*　</span><br><span class="line">		CPU主频168MHz时，在内部Flash运行, MDK工程不优化。用台式示波器观测波形。</span><br><span class="line">		循环次数为5时，SCL频率 = 1.78MHz (读耗时: 92ms, 读写正常，但是用示波器探头碰上就读写失败。时序接近临界)</span><br><span class="line">		循环次数为10时，SCL频率 = 1.1MHz (读耗时: 138ms, 读速度: 118724B/s)</span><br><span class="line">		循环次数为30时，SCL频率 = 440KHz， SCL高电平时间1.0us，SCL低电平时间1.2us</span><br><span class="line"></span><br><span class="line">		上拉电阻选择2.2K欧时，SCL上升沿时间约0.5us，如果选4.7K欧，则上升沿约1us</span><br><span class="line"></span><br><span class="line">		实际应用选择400KHz左右的速率即可</span><br><span class="line">	*/</span><br><span class="line">	<span class="keyword">for</span> (i = 0; i &lt; 30; i++);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="IIC结束信号"><a href="#IIC结束信号" class="headerlink" title="IIC结束信号"></a>IIC结束信号</h2><p>当scl时钟线为高的时候，sda出现上升沿视为IIC结束信号</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">void i2c_Stop(void)</span><br><span class="line">&#123;</span><br><span class="line">	/* 当SCL高电平时，SDA出现一个上跳沿表示I2C总线停止信号 */</span><br><span class="line">	I2C_SDA_0();</span><br><span class="line">	I2C_SCL_1();</span><br><span class="line">	i2c_Delay();</span><br><span class="line">	I2C_SDA_1();</span><br><span class="line">	i2c_Delay();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="cpu向从机发送8Bit数据"><a href="#cpu向从机发送8Bit数据" class="headerlink" title="cpu向从机发送8Bit数据"></a>cpu向从机发送8Bit数据</h2><p>先准备好数据再拉高时钟线</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">void i2c_SendByte(uint8_t _ucByte)</span><br><span class="line">&#123;</span><br><span class="line">	uint8_t i;</span><br><span class="line"></span><br><span class="line">	/* 先发送字节的高位bit7 */</span><br><span class="line">	<span class="keyword">for</span> (i = 0; i &lt; 8; i++)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">if</span> (_ucByte &amp; 0x80)       //将数据与0x80做与运算，即提取数据最高位</span><br><span class="line">		&#123;</span><br><span class="line">			I2C_SDA_1();</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">else</span></span><br><span class="line">		&#123;</span><br><span class="line">			I2C_SDA_0();</span><br><span class="line">		&#125;</span><br><span class="line">		i2c_Delay();     //在时钟线为高之前准备好数据</span><br><span class="line">		I2C_SCL_1();     //时钟线为高开始发送数据</span><br><span class="line">		i2c_Delay();</span><br><span class="line">		I2C_SCL_0();     //保持一段时间后将时钟线拉低准备下一次的传输</span><br><span class="line">		<span class="keyword">if</span> (i == 7)      //判断7个数据是否传输完成，若完成，则释放sda总线（SDA拉高）</span><br><span class="line">		&#123;</span><br><span class="line">			 I2C_SDA_1(); // 释放总线</span><br><span class="line">		&#125;</span><br><span class="line">		_ucByte &lt;&lt;= 1;	/* 左移一个bit *///将数据左移一位，即传输下一位</span><br><span class="line">		i2c_Delay();</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="cpu读取从机8Bit数据"><a href="#cpu读取从机8Bit数据" class="headerlink" title="cpu读取从机8Bit数据"></a>cpu读取从机8Bit数据</h2><p>与写数据相反，先拉高时钟线，准备好了之后读取数据</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">uint8_t i2c_ReadByte(void)</span><br><span class="line">&#123;</span><br><span class="line">	uint8_t i;</span><br><span class="line">	uint8_t value;</span><br><span class="line"></span><br><span class="line">	/* 读到第1个bit为数据的bit7 所以数据需要左移*/</span><br><span class="line">	value = 0;</span><br><span class="line">	<span class="keyword">for</span> (i = 0; i &lt; 8; i++)</span><br><span class="line">	&#123;</span><br><span class="line">		value &lt;&lt;= 1;</span><br><span class="line">		I2C_SCL_1();</span><br><span class="line">		i2c_Delay();</span><br><span class="line">		<span class="keyword">if</span> (I2C_SDA_READ())</span><br><span class="line">		&#123;</span><br><span class="line">			value++;</span><br><span class="line">		&#125;</span><br><span class="line">		I2C_SCL_0();</span><br><span class="line">		i2c_Delay();</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">return</span> value;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="主机等待从机应答"><a href="#主机等待从机应答" class="headerlink" title="主机等待从机应答"></a>主机等待从机应答</h2><p>传送完8个数据后，由CPU产生一个时钟，并读取器件的ACK应答</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">uint8_t i2c_WaitAck(void)</span><br><span class="line">&#123;</span><br><span class="line">	uint8_t re;</span><br><span class="line"></span><br><span class="line">	I2C_SDA_1();	/* CPU释放SDA总线 */</span><br><span class="line">	i2c_Delay();</span><br><span class="line">	I2C_SCL_1();	/* CPU驱动SCL = 1, 此时器件会返回ACK应答 */</span><br><span class="line">	i2c_Delay();</span><br><span class="line">	<span class="keyword">if</span> (I2C_SDA_READ())	/* CPU读取SDA口线状态 */</span><br><span class="line">	&#123;</span><br><span class="line">		re = 1;         //为1则是无响应</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">else</span></span><br><span class="line">	&#123;</span><br><span class="line">		re = 0;</span><br><span class="line">	&#125;</span><br><span class="line">	I2C_SCL_0();</span><br><span class="line">	i2c_Delay();</span><br><span class="line">	<span class="built_in">return</span> re;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="主机产生ACK信号"><a href="#主机产生ACK信号" class="headerlink" title="主机产生ACK信号"></a>主机产生ACK信号</h2><p>当主机接收到8位数据后会产生ACK应答信号</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">void i2c_Ack(void)</span><br><span class="line">&#123;</span><br><span class="line">	I2C_SDA_0();	/* CPU驱动SDA = 0 */</span><br><span class="line">	i2c_Delay();</span><br><span class="line">	I2C_SCL_1();	/* CPU产生1个时钟 */</span><br><span class="line">	i2c_Delay();</span><br><span class="line">	I2C_SCL_0();</span><br><span class="line">	i2c_Delay();</span><br><span class="line">	I2C_SDA_1();	/* CPU释放SDA总线 */</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="主机产生Nack无应答信号"><a href="#主机产生Nack无应答信号" class="headerlink" title="主机产生Nack无应答信号"></a>主机产生Nack无应答信号</h2><p>通常用于数据传输结束</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">void i2c_NAck(void)</span><br><span class="line">&#123;</span><br><span class="line">	I2C_SDA_1();	/* CPU驱动SDA = 1 */</span><br><span class="line">	i2c_Delay();</span><br><span class="line">	I2C_SCL_1();	/* CPU产生1个时钟 */</span><br><span class="line">	i2c_Delay();</span><br><span class="line">	I2C_SCL_0();</span><br><span class="line">	i2c_Delay();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="模拟IIC引脚初始化"><a href="#模拟IIC引脚初始化" class="headerlink" title="模拟IIC引脚初始化"></a>模拟IIC引脚初始化</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">void bsp_InitI2C(void)</span><br><span class="line">&#123;</span><br><span class="line">	GPIO_InitTypeDef GPIO_InitStructure;</span><br><span class="line"></span><br><span class="line">	RCC_APB2PeriphClockCmd(RCC_I2C_PORT, ENABLE);	/* 打开GPIO时钟 */</span><br><span class="line"></span><br><span class="line">	GPIO_InitStructure.GPIO_Speed = GPIO_Speed_50MHz;</span><br><span class="line">	GPIO_InitStructure.GPIO_Mode = GPIO_Mode_Out_OD;	/* 开漏输出模式 */</span><br><span class="line">	</span><br><span class="line">	GPIO_InitStructure.GPIO_Pin = PIN_I2C_SCL;</span><br><span class="line">	GPIO_Init(PORT_I2C_SCL, &amp;GPIO_InitStructure);</span><br><span class="line"></span><br><span class="line">	GPIO_InitStructure.GPIO_Pin = PIN_I2C_SDA;</span><br><span class="line">	GPIO_Init(PORT_I2C_SDA, &amp;GPIO_InitStructure);</span><br><span class="line"></span><br><span class="line">	/* 给一个停止信号, 复位I2C总线上的所有设备到待机模式 */</span><br><span class="line">	i2c_Stop();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="引脚相关宏定义"><a href="#引脚相关宏定义" class="headerlink" title="引脚相关宏定义"></a>引脚相关宏定义</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#define I2C_WR	0		/* 写控制bit */</span></span><br><span class="line"><span class="comment">#define I2C_RD	1		/* 读控制bit */</span></span><br><span class="line"><span class="comment">#define RCC_I2C_PORT 	RCC_APB2Periph_GPIOB		/* GPIO端口时钟 */</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#define PORT_I2C_SCL	GPIOB			/* GPIO端口 */</span></span><br><span class="line"><span class="comment">#define PIN_I2C_SCL		GPIO_Pin_6		/* GPIO引脚 */</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#define PORT_I2C_SDA	GPIOB			/* GPIO端口 */</span></span><br><span class="line"><span class="comment">#define PIN_I2C_SDA		GPIO_Pin_5	/* GPIO引脚 */</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#define I2C_SCL_PIN		GPIO_Pin_6			/* 连接到SCL时钟线的GPIO */</span></span><br><span class="line"><span class="comment">#define I2C_SDA_PIN		GPIO_Pin_5			/* 连接到SDA数据线的GPIO */</span></span><br><span class="line"></span><br><span class="line">/* 定义读写SCL和SDA的宏 */</span><br><span class="line"><span class="comment">#define I2C_SCL_1()  PORT_I2C_SCL-&gt;BSRR = I2C_SCL_PIN				/* SCL = 1 */</span></span><br><span class="line"><span class="comment">#define I2C_SCL_0()  PORT_I2C_SCL-&gt;BRR = I2C_SCL_PIN				/* SCL = 0 */</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#define I2C_SDA_1()  PORT_I2C_SDA-&gt;BSRR = I2C_SDA_PIN				/* SDA = 1 */</span></span><br><span class="line"><span class="comment">#define I2C_SDA_0()  PORT_I2C_SDA-&gt;BRR = I2C_SDA_PIN				/* SDA = 0 */</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#define I2C_SDA_READ()  ((PORT_I2C_SDA-&gt;IDR &amp; I2C_SDA_PIN) != 0)	/* 读SDA口线状态 */</span></span><br><span class="line"><span class="comment">#define I2C_SCL_READ()  ((PORT_I2C_SCL-&gt;IDR &amp; I2C_SCL_PIN) != 0)	/* 读SCL口线状态 */</span></span><br></pre></td></tr></table></figure>

      
    </div>
    <footer class="article-footer">
      <a data-url="https://zwz522623.github.io.git/2020/08/01/%E8%BD%AF%E4%BB%B6%E6%A8%A1%E6%8B%9FIIC/" data-id="ckdbklg660000sgur8ps4g05m" class="article-share-link">分享</a>
      
      
    </footer>
  </div>
  
</article>




  
    <article id="post-互补PWM" class="wow slideInRight article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2020/07/30/%E4%BA%92%E8%A1%A5PWM/" class="article-date">
  <time class="post-time" datetime="2020-07-30T12:29:13.133Z" itemprop="datePublished">
    <span class="post-month">7月</span><br/>
    <span class="post-day">30</span>
  </time>
</a>
   
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2020/07/30/%E4%BA%92%E8%A1%A5PWM/">互补PWM实验</a>
    </h1>
  

        <div>
          
          
              

          
        </div>
      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br></pre></td><td class="code"><pre><span class="line">static void ADVANCE_TIM_GPIO_Config(void)</span><br><span class="line">&#123;</span><br><span class="line">		GPIO_InitTypeDef   GPIO_InitStruct;</span><br><span class="line">		//输出比较通道GPIO初始化</span><br><span class="line">		RCC_APB2PeriphClockCmd(RCC_APB2Periph_GPIOA,ENABLE);</span><br><span class="line">		GPIO_InitStruct.GPIO_Mode = GPIO_Mode_AF_PP;</span><br><span class="line">		GPIO_InitStruct.GPIO_Pin = GPIO_Pin_8;</span><br><span class="line">		GPIO_InitStruct.GPIO_Speed = GPIO_Speed_50MHz;</span><br><span class="line">		GPIO_Init(GPIOA,&amp;GPIO_InitStruct);</span><br><span class="line">		//输出比较互补通道GPIO初始化</span><br><span class="line">		RCC_APB2PeriphClockCmd(RCC_APB2Periph_GPIOB,ENABLE);</span><br><span class="line">		GPIO_InitStruct.GPIO_Mode = GPIO_Mode_AF_PP;</span><br><span class="line">		GPIO_InitStruct.GPIO_Pin = GPIO_Pin_13;</span><br><span class="line">		GPIO_InitStruct.GPIO_Speed = GPIO_Speed_50MHz;</span><br><span class="line">		GPIO_Init(GPIOB,&amp;GPIO_InitStruct);</span><br><span class="line">		//输出比较刹车通道GPIO初始化</span><br><span class="line">		RCC_APB2PeriphClockCmd(RCC_APB2Periph_GPIOB,ENABLE);</span><br><span class="line">		GPIO_InitStruct.GPIO_Mode = GPIO_Mode_AF_PP;</span><br><span class="line">		GPIO_InitStruct.GPIO_Pin = GPIO_Pin_12;</span><br><span class="line">		GPIO_InitStruct.GPIO_Speed = GPIO_Speed_50MHz;</span><br><span class="line">		//BKIN引脚先默认输出低电平</span><br><span class="line">		GPIO_ResetBits(GPIOB,GPIO_Pin_12);</span><br><span class="line">		</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">static void ADVANE_TIM_MODE_Config(void)</span><br><span class="line">&#123;</span><br><span class="line">		RCC_APB2PeriphClockCmd(RCC_APB2Periph_TIM1,ENABLE);</span><br><span class="line">		//时基结构体初始化	</span><br><span class="line">		TIM_TimeBaseInitTypeDef    TIM_TimeBaseInitStruct;</span><br><span class="line">		//自动重装载寄存器的值，累计TIM_Period+1的频率后产生一个中断或者更新</span><br><span class="line">		TIM_TimeBaseInitStruct.TIM_Period = ADVANCE_TIM_PERIOD;</span><br><span class="line">		//驱动CNT计数器的时钟 = Fck_int/(psc+1)，他和上面决定了PWM的周期</span><br><span class="line">		TIM_TimeBaseInitStruct.TIM_Prescaler = ADVANCE_TIM_PSC;</span><br><span class="line">		//时钟分频因子，配置死区时间用到</span><br><span class="line">		TIM_TimeBaseInitStruct.TIM_ClockDivision = TIM_CKD_DIV1;</span><br><span class="line">		// 计数器计数模式设置为向上计数</span><br><span class="line">		TIM_TimeBaseInitStruct.TIM_CounterMode = TIM_CounterMode_Up;</span><br><span class="line">		//重复计数器的值，没用到不用管</span><br><span class="line">		TIM_TimeBaseInitStruct.TIM_RepetitionCounter = 0;</span><br><span class="line">		//初始化定时器</span><br><span class="line">		TIM_TimeBaseInit(TIM1,&amp;TIM_TimeBaseInitStruct);</span><br><span class="line">		</span><br><span class="line">		//输出比较结构体初始化</span><br><span class="line">		TIM_OCInitTypeDef    TIM_OCInitStruct;</span><br><span class="line">		//配置模式为PWM1</span><br><span class="line">		TIM_OCInitStruct.TIM_OCMode = TIM_OCMode_PWM1;</span><br><span class="line">		//输出使能</span><br><span class="line">		TIM_OCInitStruct.TIM_OutputState = TIM_OutputState_Enable;</span><br><span class="line">		//互补输出使能</span><br><span class="line">		TIM_OCInitStruct.TIM_OutputNState = TIM_OutputNState_Enable;</span><br><span class="line">		//设置占空比大小</span><br><span class="line">		TIM_OCInitStruct.TIM_Pulse = ADVANCE_TIM_PULSE;</span><br><span class="line">		//输出通道电平极性配置</span><br><span class="line">		TIM_OCInitStruct.TIM_OCPolarity = TIM_OCPolarity_High;</span><br><span class="line">		//互补通道电平极性配置</span><br><span class="line">		TIM_OCInitStruct.TIM_OCNPolarity = TIM_OCNPolarity_High;</span><br><span class="line">		//输出通道空闲电平配置</span><br><span class="line">		TIM_OCInitStruct.TIM_OCIdleState = TIM_OCIdleState_Set;</span><br><span class="line">		//互补通道空闲电平配置</span><br><span class="line">		TIM_OCInitStruct.TIM_OCNIdleState = TIM_OCNIdleState_Reset;</span><br><span class="line">		TIM_OC1Init(TIM1,&amp;TIM_OCInitStruct);</span><br><span class="line">		TIM_OC1PreloadConfig(TIM1,TIM_OCPreload_Enable);</span><br><span class="line">		</span><br><span class="line">		//刹车和死区结构体初始化</span><br><span class="line">		TIM_BDTRInitTypeDef    TIM_BDTRInitStruct;</span><br><span class="line">		//有关刹车和死区结构体的成员具体可参考BDTR寄存器的描述、</span><br><span class="line">		TIM_BDTRInitStruct.TIM_OSSRState = TIM_OSSRState_Enable;</span><br><span class="line">		TIM_BDTRInitStruct.TIM_OSSIState = TIM_OSSIState_Enable;</span><br><span class="line">		TIM_BDTRInitStruct.TIM_LOCKLevel = TIM_LOCKLevel_1;</span><br><span class="line">		//输出比较信号死区时间配置，计算方法参考BDTR:UTG[7:0]的描述</span><br><span class="line">		//这里配置为152ns</span><br><span class="line">		TIM_BDTRInitStruct.TIM_DeadTime = 11;</span><br><span class="line">		TIM_BDTRInitStruct.TIM_Break = TIM_Break_Enable;</span><br><span class="line">		//当BKIN引脚检测到高电平的时候，输出信号禁止，如同刹车一般</span><br><span class="line">		TIM_BDTRInitStruct.TIM_BreakPolarity = TIM_BreakPolarity_High;</span><br><span class="line">		TIM_BDTRInitStruct.TIM_AutomaticOutput = TIM_AutomaticOutput_Enable;</span><br><span class="line">		TIM_BDTRConfig(TIM1,&amp;TIM_BDTRInitStruct);</span><br><span class="line">		</span><br><span class="line">		//使能计数器</span><br><span class="line">		TIM_Cmd(TIM1,ENABLE);</span><br><span class="line">		//主输出使能，当使用的是通用定时器时，这句不需要</span><br><span class="line">		TIM_CtrlPWMOutputs(TIM1,ENABLE);</span><br><span class="line">	</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void ADVANCE_TIM_Init(void)</span><br><span class="line">&#123;</span><br><span class="line">	ADVANCE_TIM_GPIO_Config();</span><br><span class="line">	ADVANE_TIM_MODE_Config();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>无中断，在主函数中调用ADVANCE_TIM_Init();即可输出互补的带死区时间刹车控制的PWM</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="https://zwz522623.github.io.git/2020/07/30/%E4%BA%92%E8%A1%A5PWM/" data-id="ckd8s0y5d0000q0ure3ib0e6l" class="article-share-link">分享</a>
      
      
    </footer>
  </div>
  
</article>




  
    <article id="post-高级定时器" class="wow slideInRight article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2020/07/30/%E9%AB%98%E7%BA%A7%E5%AE%9A%E6%97%B6%E5%99%A8/" class="article-date">
  <time class="post-time" datetime="2020-07-30T11:26:57.409Z" itemprop="datePublished">
    <span class="post-month">7月</span><br/>
    <span class="post-day">30</span>
  </time>
</a>
   
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2020/07/30/%E9%AB%98%E7%BA%A7%E5%AE%9A%E6%97%B6%E5%99%A8/">高级定时器简介</a>
    </h1>
  

        <div>
          
          
              

          
        </div>
      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h2 id="定时器特性"><a href="#定时器特性" class="headerlink" title="定时器特性"></a>定时器特性</h2><p><img src="https://s1.ax1x.com/2020/07/30/aKBwgU.png" alt="定时器特性"></p>
<p>高级定时器简介<br>1）16bit计数器，上下两边计数。通道为TIM1与TIM8,独有重复计数器<br>2）有四个GPIO,其中通道一到三还有互补输出<br>3）时钟来自PCLK2,为72M，可实现1-65536分频<br>注：基本与通用定时器的时钟源来自PCLK1</p>
<h2 id="高级定时器功能框图"><a href="#高级定时器功能框图" class="headerlink" title="高级定时器功能框图"></a>高级定时器功能框图</h2><p><a href="https://imgchr.com/i/aKDyQS" target="_blank" rel="noopener"><img src="https://s1.ax1x.com/2020/07/30/aKDyQS.md.png" alt="高级定时器功能框图"></a></p>
<h3 id="时钟源"><a href="#时钟源" class="headerlink" title="时钟源"></a>时钟源</h3><p>1、内部时钟源：CK_INT<br>2、外部时钟模式1–外部的GPIOx(x=1,2,3,4)<br>3、外部时钟模式2–外部的GPIO ETR<br>4、内部触发输入<br>注：2,3,4均不常用</p>
<h3 id="控制器"><a href="#控制器" class="headerlink" title="控制器"></a>控制器</h3><p>用来控制及发送命令<br>主要学习CR1,CR2,SMCR,CCER几个即可</p>
<h3 id="时基单元"><a href="#时基单元" class="headerlink" title="时基单元"></a>时基单元</h3><p><a href="https://imgchr.com/i/aKrNlT" target="_blank" rel="noopener"><img src="https://s1.ax1x.com/2020/07/30/aKrNlT.md.png" alt="时基单元"></a><br>1、预分频器：TIM_PSC:对PCLK分频<br>2、16位计数器<br>3、8位重复计数器<br>4、16位的自动重装载计数器</p>
<h2 id="自举电容"><a href="#自举电容" class="headerlink" title="自举电容"></a>自举电容</h2><p><a href="https://imgchr.com/i/aKs8De" target="_blank" rel="noopener"><img src="https://s1.ax1x.com/2020/07/30/aKs8De.png" alt="半桥电路"></a><br>半桥电路的下半桥比较容易理解，无非就是G,S之间达到了导通电压，MOS导通，但是当上半桥导通的时候，<br>如果不看由二极管和电容组成的自举部分，HO的输出是不可能大于VS的，这个时候就需要自举电路部分了，<br>一开始，由电源通过二极管为电容充电，当上管导通时，VS端电压上升，由于二极管的存在，阻止了电容的<br>放电，所以电容两端的电压差不变，就可以持续的导通MOS。其中VB端的电压是由内部的两个串联的mos决定<br>是否加到HO的高侧栅极驱动端<br><a href="https://imgchr.com/i/aK6KOO" target="_blank" rel="noopener"><img src="https://s1.ax1x.com/2020/07/30/aK6KOO.th.png" alt="ir2181内部电路"></a></p>
<h2 id="初始化结构体"><a href="#初始化结构体" class="headerlink" title="初始化结构体"></a>初始化结构体</h2><p><a href="https://imgchr.com/i/aKcDKK" target="_blank" rel="noopener"><img src="https://s1.ax1x.com/2020/07/30/aKcDKK.png" alt="时基初始化结构体"></a><br>TIM_Prescaler：定时器预分频器设置，时钟源经该预分频器才是定时器计数时钟CK_CNT，它设定 PSC 寄存器的值。<br>计算公式为： 计数器时钟频率 (fCK_CNT) 等于fCK_PSC / (PSC[15:0] + 1)，可实现 1 至 65536 分频<br>TIM_CounterMode：定时器计数方式，可设置为向上计数、向下计数以及中心对齐。高级控制定时器允许选择任意一种。<br>TIM_Period：定时器周期，实际就是设定自动重载寄存器 ARR 的值， ARR 为要装载到实际自动重载寄存器（即影子<br>寄存器） 的值， 可设置范围为 0 至 65535<br>TIM_ClockDivision：时钟分频，设置定时器时钟 CK_INT 频率与死区发生器以及数字滤波器采样时钟频率分频比。<br>可以选择 1、 2、 4 分频。<br>TIM_RepetitionCounter：重复计数器，只有 8 位，只存在于高级定时器。<br><img src="https://s1.ax1x.com/2020/07/30/aKgKde.png" alt="输出比较初始化结构体"><br>TIM_OCMode：比较输出模式选择，总共有八种，常用的为 PWM1/PWM2。它设定CCMRx 寄存器 OCxM[2:0]位的值。<br>TIM_OutputState：比较输出使能，决定最终的输出比较信号 OCx 是否通过外部引脚输出。它设定 TIMx_CCER<br>寄存器 CCxE 位的值<br>TIM_OutputNState:比较互补输出使能，决定 OCx 的互补信号 OCxN 是否通过外部引脚输出。它设定 CCER 寄存<br>器 CCxNE 位的值。<br>TIM_Pulse：比较输出脉冲宽度，实际设定比较寄存器 CCR 的值，决定脉冲宽度。可设置范围为 0 至 65535。<br>TIM_OCPolarity：比较输出极性，可选 OCx 为高电平有效或低电平有效。它决定着定时器通道有效电平。它设定<br>CCER 寄存器的 CCxP 位的值。<br>TIM_OCNPolarity：比较互补输出极性，可选OCxN 为高电平有效或低电平有效。它设定 TIMx_CCER 寄存器的<br>CCxNP 位的值。<br>TIM_OCIdleState：空闲状态时通道输出电平设置，可选输出 1 或输出 0，即在空闲状态(BDTR_MOE 位为 0)时，经过死区时间后定时器通道输出高电平或低电平。它设定CR2 寄存器的 OISx 位的值。<br>TIM_OCNIdleState：空闲状态时互补通道输出电平设置，可选输出 1 或输出 0，即在空闲状态(BDTR_MOE 位为 0)时，经过死区时间后定时器互补通道输出高电平或低电平，设定值必须与 TIM_OCIdleState 相反。它设定是 CR2 寄<br>存器的 OISxN 位的值。<br><img src="https://s1.ax1x.com/2020/07/30/aK2kTg.png" alt="输入捕获初始化结构体"><br>TIM_Channel：捕获通道 ICx 选择，可选<br> TIM_Channel_1、 TIM_Channel_2<br>TIM_Channel_3 或 TIM_Channel_4 四个通道。它设定 CCMRx 寄存器 CCxS 位 的值。<br>TIM_ICPolarity：输入捕获边沿触发选择，可选上升沿触发、下降沿触发或边沿跳变触发。它设定 CCER 寄存器 CCxP 位和<br>CCxNP 位的值。<br>TIM_ICSelection：输入通道选择，捕获通道 ICx 的信号可来自三个输入通道，分别为<br>TIM_ICSelection_DirectTI、<br>TIM_ICSelection_IndirectTI 或<br>TIM_ICSelection_TRC<br>它设定 CCRMx 寄存器的 CCxS[1:0]位的值。<br><img src="https://s1.ax1x.com/2020/07/30/aK2fnf.png" alt="断路和死区初始化结构体"><br>有关这个结构体的成员的含义只需要参考断路和死区寄存器：TIMx_BDTR即可。</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="https://zwz522623.github.io.git/2020/07/30/%E9%AB%98%E7%BA%A7%E5%AE%9A%E6%97%B6%E5%99%A8/" data-id="ckd8qw5b00000xgurccyja3gp" class="article-share-link">分享</a>
      
      
    </footer>
  </div>
  
</article>




  
    <article id="post-基本定时器" class="wow slideInRight article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2020/07/28/%E5%9F%BA%E6%9C%AC%E5%AE%9A%E6%97%B6%E5%99%A8/" class="article-date">
  <time class="post-time" datetime="2020-07-28T09:48:55.601Z" itemprop="datePublished">
    <span class="post-month">7月</span><br/>
    <span class="post-day">28</span>
  </time>
</a>
   
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2020/07/28/%E5%9F%BA%E6%9C%AC%E5%AE%9A%E6%97%B6%E5%99%A8/">基本定时器</a>
    </h1>
  

        <div>
          
          
              

          
        </div>
      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>STM32的定时器分类有以下三种：<br>(1):基本定时器(只有定时功能)<br>(2):通用定时器(输出比较，输入捕获)<br>(3):高级定时器(包括了基本定时器与通用定时器)</p>
<h2 id="基本定时器特性"><a href="#基本定时器特性" class="headerlink" title="基本定时器特性"></a>基本定时器特性</h2><p>1)16BIT计数器，只能向上计数，通道只有定时器TIM6与TIM7.<br>2)内部资源，没有外部的GPIO,只能定时。<br>3)时钟来自PCLK1,为72M,可实现1-65536分频。</p>
<h2 id="时基初始化结构体"><a href="#时基初始化结构体" class="headerlink" title="时基初始化结构体"></a>时基初始化结构体</h2><p><a href="https://imgchr.com/i/aEbF8s" target="_blank" rel="noopener"><img src="https://s1.ax1x.com/2020/07/28/aEbF8s.png" alt="时基初始化结构体"></a><br>由于基本定时器只能向上计数，所以计数模式不用配置。<br>外部时钟分频因子，基本定时器没有，所以也不用配置。<br>重复计数器是高级定时器专用，也不用配置。<br>使能时钟的时候要注意TIM6的时钟是挂载在APB1外设上的。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">void TIMx_Config(void)</span><br><span class="line">&#123;</span><br><span class="line">	  TIM_TimeBaseInitTypeDef TIM_TimeBaseInitStruct;	</span><br><span class="line">	  RCC_APB1PeriphClockCmd(RCC_APB1Periph_TIM6,ENABLE);</span><br><span class="line">	  TIM_TimeBaseInitStruct.TIM_Prescaler = 71;//分频因子71，分频数为71+1=72，所以分频结束为1M</span><br><span class="line">	  TIM_TimeBaseInitStruct.TIM_Period = 3999; //中断周期从零计数到3999，计数4000次所以中断周期为1000*4/1000000=4ms</span><br><span class="line">	  TIM_TimeBaseInit(TIM6,&amp;TIM_TimeBaseInitStruct);//将配置好的数据写入到寄存器</span><br><span class="line">	  // 清除计数器中断标志位</span><br><span class="line">      TIM_ClearFlag(TIM6, TIM_FLAG_Update);</span><br><span class="line">	  // 开启计数器中断</span><br><span class="line">      TIM_ITConfig(TIM6,TIM_IT_Update,ENABLE);</span><br><span class="line">      // 使能计数器</span><br><span class="line">      TIM_Cmd(TIM6, ENABLE);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="基本定时器需要配置的结构体参数有"><a href="#基本定时器需要配置的结构体参数有" class="headerlink" title="基本定时器需要配置的结构体参数有:"></a>基本定时器需要配置的结构体参数有:</h3><p>TIM_Prescaler(预分频因子)，例程配置如下：<br>    TIM_TimeBaseInitStruct.TIM_Prescaler = 71;<br>    分频因子71，分频数为71+1=72，所以分频结束为1M<br>    TIM_Period(自动重装载值)，通过调节这个调节中断周期，配置方法及计算方法如下：<br>    TIM_TimeBaseInitStruct.TIM_Period = 3999;<br>    中断周期从零计数到3999，计数4000次所以中断周期为1000*4/1000000=4ms<br>接下来要做的便是使能中断</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">static void NVIC_Config(void)</span><br><span class="line">&#123;</span><br><span class="line">		NVIC_InitTypeDef NVIC_InitStruct;</span><br><span class="line">		//配置中断优先级分组</span><br><span class="line">		NVIC_PriorityGroupConfig(NVIC_PriorityGroup_0);</span><br><span class="line">		//配置中断初始化结构体</span><br><span class="line">		NVIC_InitStruct.NVIC_IRQChannel = TIM6_IRQn;</span><br><span class="line">		NVIC_InitStruct.NVIC_IRQChannelPreemptionPriority = 1;</span><br><span class="line">		NVIC_InitStruct.NVIC_IRQChannelSubPriority = 1;</span><br><span class="line">		NVIC_InitStruct.NVIC_IRQChannelCmd = ENABLE;</span><br><span class="line">		NVIC_Init(&amp;NVIC_InitStruct);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>中断配置好之后在初始化函数中调用即可完成定时器中断的初始化：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">void TIMx_Init(void)</span><br><span class="line">&#123;</span><br><span class="line">		NVIC_Config();</span><br><span class="line">		TIMx_Config();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>完成这些之后便是对中断服务函数进行配置</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">void TIM6_IRQHandler()</span><br><span class="line">&#123;</span><br><span class="line">		<span class="keyword">if</span>(TIM_GetITStatus(TIM6,TIM_IT_Update)!=RESET)</span><br><span class="line">		&#123;</span><br><span class="line">			time++;</span><br><span class="line">			TIM_ClearITPendingBit(TIM6,TIM_FLAG_Update);</span><br><span class="line">		&#125;</span><br><span class="line">		</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>需要注意的是中断服务函数的名字不能搞错，进中断之前判断是否产生中断<br>结束之后清除中断标志位<br>之后在主函数中调用Timx_Init()函数就能调用定时器中断了。<br><img src="https://s1.ax1x.com/2020/07/28/aV9uCV.jpg" alt="不要停下来啊"></p>

      
    </div>
    <footer class="article-footer">
      <a data-url="https://zwz522623.github.io.git/2020/07/28/%E5%9F%BA%E6%9C%AC%E5%AE%9A%E6%97%B6%E5%99%A8/" data-id="ckd5xazgp0000ukur4x5b7wmj" class="article-share-link">分享</a>
      
      
    </footer>
  </div>
  
</article>




  
    <article id="post-STM32 DMA读取多通道ADC" class="wow slideInRight article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2020/07/26/STM32%20DMA%E8%AF%BB%E5%8F%96%E5%A4%9A%E9%80%9A%E9%81%93ADC/" class="article-date">
  <time class="post-time" datetime="2020-07-26T11:28:18.315Z" itemprop="datePublished">
    <span class="post-month">7月</span><br/>
    <span class="post-day">26</span>
  </time>
</a>
   
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2020/07/26/STM32%20DMA%E8%AF%BB%E5%8F%96%E5%A4%9A%E9%80%9A%E9%81%93ADC/">STM32 DMA读取多通道ADC</a>
    </h1>
  

        <div>
          
          
              

          
        </div>
      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>由于ADC规则通道中只有一个寄存器，如果同时读取多个ADC<br>的数值会造成数据的覆盖，这个时候就需要用到DMA技术，将<br>读取到的ADC值暂存，等全部转换完成后再转换。</p>
<h2 id="DMA初始化结构体"><a href="#DMA初始化结构体" class="headerlink" title="DMA初始化结构体"></a>DMA初始化结构体</h2><p><img src="https://s1.ax1x.com/2020/07/26/aCPrK1.md.png" alt="DMA初始化结构体"><br>因为这次是选择通过DMA读取多路ADC1的值，所以复位控制器选择(ADC1对应DMA1<br>通道1，ADC3对应DMA3通道5，ADC2没有DMA功能)DMA1的通道1.外设基址选择DR寄<br>存器，储存器地址选择缓存的数组。数据源选择外设，缓冲区大小,应该等于数据目<br>的地的大小，这里和通道数一致。外设寄存器只有一个，地址不用递增，但是存储器<br>地址递增，外设数据与内存数据大小都为半字，即两个字节。传输模式选择循环传输。<br>DMA传输优先级为高，当使用一个DMA通道时，优先级设置不受影响，因为是从外设到<br>存储器，所以禁止储存器到储存器模式。初始化DMA后使能DMA通道，等待ADC的DMA请求。<br>需要注意的是DMA的时钟挂载的并不是APB2,而是AHB外设时钟。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">DMA_InitTypeDef  DMA_InitStruct;</span><br><span class="line">//打开dma时钟</span><br><span class="line">RCC_AHBPeriphClockCmd(ADC_DMA_CLK,ENABLE);</span><br><span class="line">//复位DMA控制器</span><br><span class="line">DMA_DeInit(ADC_DMA_CHANNEL);</span><br><span class="line">//初始化DMA初始化结构体</span><br><span class="line">   //外设基址为:ADC数据寄存器地址</span><br><span class="line">DMA_InitStruct.DMA_PeripheralBaseAddr = (u32)(&amp;(ADC_x-&gt;DR));</span><br><span class="line">   //存储器地址</span><br><span class="line">DMA_InitStruct.DMA_MemoryBaseAddr = (u32)ADC_ConvertedValue;</span><br><span class="line">//数据源来自外设</span><br><span class="line">DMA_InitStruct.DMA_DIR = DMA_DIR_PeripheralSRC;</span><br><span class="line">//缓冲区大小,应该等于数据目的地的大小</span><br><span class="line">DMA_InitStruct.DMA_BufferSize = NOFCHANEL;</span><br><span class="line">//外设寄存器只有一个，地址不用递增</span><br><span class="line">DMA_InitStruct.DMA_PeripheralInc = DMA_PeripheralInc_Disable;</span><br><span class="line">//存储器地址递增</span><br><span class="line">DMA_InitStruct.DMA_MemoryInc = DMA_MemoryInc_Enable;</span><br><span class="line">//外设数据大小为半字，即两个字节</span><br><span class="line">DMA_InitStruct.DMA_PeripheralDataSize = DMA_PeripheralDataSize_HalfWord;</span><br><span class="line">//内存大小数据也为半字，跟外设数据大小相同</span><br><span class="line">DMA_InitStruct.DMA_MemoryDataSize = DMA_MemoryDataSize_HalfWord;</span><br><span class="line">//循环传输模式</span><br><span class="line">DMA_InitStruct.DMA_Mode = DMA_Mode_Circular;</span><br><span class="line">//DMA传输优先级为高，当使用一个DMA通道时，优先级设置不受影响</span><br><span class="line">DMA_InitStruct.DMA_Priority = DMA_Priority_High;</span><br><span class="line">//禁止储存器到储存器模式，因为是从外设到储存器</span><br><span class="line">DMA_InitStruct.DMA_M2M = DMA_M2M_Disable;</span><br><span class="line">//初始化DMA</span><br><span class="line">DMA_Init(ADC_DMA_CHANNEL,&amp;DMA_InitStruct);</span><br><span class="line">//使能DMA通道</span><br><span class="line">DMA_Cmd(ADC_DMA_CHANNEL,ENABLE);</span><br></pre></td></tr></table></figure>
<h2 id="ADC初始化"><a href="#ADC初始化" class="headerlink" title="ADC初始化"></a>ADC初始化</h2><p>ADC的初始化与单个的ADC初始化大概一致，增加了ADC的DMA请求，并对ADC读取顺序做出了规定</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">//打开ADC时钟</span><br><span class="line">RCC_APB2PeriphClockCmd(RCC_APB2Periph_ADC1,ENABLE);</span><br><span class="line">//只使用1个ADC，属于单模式</span><br><span class="line">ADC_InitStruct.ADC_Mode = ADC_Mode_Independent;</span><br><span class="line">ADC_InitStruct.ADC_ScanConvMode = ENABLE;</span><br><span class="line">ADC_InitStruct.ADC_ContinuousConvMode = ENABLE;</span><br><span class="line">ADC_InitStruct.ADC_ExternalTrigConv = ADC_ExternalTrigConv_None;</span><br><span class="line">ADC_InitStruct.ADC_DataAlign = ADC_DataAlign_Right;</span><br><span class="line">ADC_InitStruct.ADC_NbrOfChannel = NOFCHANEL;</span><br><span class="line">ADC_Init(ADC_x,&amp;ADC_InitStruct);</span><br><span class="line">	</span><br><span class="line">RCC_ADCCLKConfig(RCC_PCLK2_Div8);</span><br><span class="line">ADC_RegularChannelConfig(ADC_x,ADC_Channel1,1,ADC_SampleTime_13Cycles5);</span><br><span class="line"> 	ADC_RegularChannelConfig(ADC_x,ADC_Channel2,2,ADC_SampleTime_13Cycles5);</span><br><span class="line"> 	ADC_RegularChannelConfig(ADC_x,ADC_Channel3,3,ADC_SampleTime_13Cycles5);</span><br><span class="line"> 	ADC_RegularChannelConfig(ADC_x,ADC_Channel4,4,ADC_SampleTime_13Cycles5);</span><br><span class="line"> 	ADC_RegularChannelConfig(ADC_x,ADC_Channel5,5,ADC_SampleTime_13Cycles5);</span><br><span class="line">ADC_RegularChannelConfig(ADC_x,ADC_Channel6,6,ADC_SampleTime_13Cycles5);</span><br><span class="line"></span><br><span class="line">//使能ADC DMA请求</span><br><span class="line">ADC_DMACmd(ADC_x,ENABLE);</span><br><span class="line">//开启ADC,并开始转换</span><br><span class="line">ADC_Cmd(ADC_x,ENABLE);</span><br><span class="line">//初始化ADC校准寄存器</span><br><span class="line">ADC_ResetCalibration(ADC_x);</span><br><span class="line">//等待校准寄存器初始化完成</span><br><span class="line"><span class="keyword">while</span>(ADC_GetResetCalibrationStatus(ADC_x));</span><br><span class="line">//ADC开始校准</span><br><span class="line">ADC_StartCalibration(ADC_x);</span><br><span class="line">//等待校准完成</span><br><span class="line"><span class="keyword">while</span>(ADC_GetCalibrationStatus(ADC_x));</span><br><span class="line">//由于没有使用外部触发，所以使用软件ADC触发</span><br><span class="line">ADC_SoftwareStartConvCmd(ADC_x,ENABLE);</span><br></pre></td></tr></table></figure>
<p>其中ADC_ConvertedValue[NOFCHANEL]为全局变量。DMA读取到ADC值后存到这个数组里。<br><img src="https://s1.ax1x.com/2020/07/26/aCkSEV.png" alt="ADC采样效果"></p>

      
    </div>
    <footer class="article-footer">
      <a data-url="https://zwz522623.github.io.git/2020/07/26/STM32%20DMA%E8%AF%BB%E5%8F%96%E5%A4%9A%E9%80%9A%E9%81%93ADC/" data-id="ckd30laps0000m4ur9zvs8pb2" class="article-share-link">分享</a>
      
      
    </footer>
  </div>
  
</article>




  
    <article id="post-stm32_ADC(独立模式单通道)" class="wow slideInRight article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2020/07/26/stm32_ADC(%E7%8B%AC%E7%AB%8B%E6%A8%A1%E5%BC%8F%E5%8D%95%E9%80%9A%E9%81%93)/" class="article-date">
  <time class="post-time" datetime="2020-07-26T06:34:21.677Z" itemprop="datePublished">
    <span class="post-month">7月</span><br/>
    <span class="post-day">26</span>
  </time>
</a>
   
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2020/07/26/stm32_ADC(%E7%8B%AC%E7%AB%8B%E6%A8%A1%E5%BC%8F%E5%8D%95%E9%80%9A%E9%81%93)/">STM32 ADC功能实现</a>
    </h1>
  

        <div>
          
          
              

          
        </div>
      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>STM32的外部16个通道分为规则通道和注入通道。注入通道最多有<br>四路。<br>这篇文章针对于stm32的独立模式单通道中断读取AD值。<br>编写ad采集程序分为以下几步：</p>
<h2 id="ADC初始化"><a href="#ADC初始化" class="headerlink" title="ADC初始化"></a>ADC初始化</h2><h3 id="初始化ADC用到的GPIO"><a href="#初始化ADC用到的GPIO" class="headerlink" title="初始化ADC用到的GPIO"></a>初始化ADC用到的GPIO</h3><p>初始化GPIO是使用ADC外设的时候不可缺少的一部分，通过芯片手册<br>上标注好的ADC引脚图选择ADC引脚并对其初始化。下图是ZET6的ADC<br>引脚分布：<br><img src="https://s1.ax1x.com/2020/07/26/a9tUKI.md.png" alt="ZET6ADC引脚分布"><br>这里我们初始化GPIO的代码就不再赘述，忘了的话可以翻阅一下前面<br>的文章。</p>
<h3 id="初始化ADC初始化结构体"><a href="#初始化ADC初始化结构体" class="headerlink" title="初始化ADC初始化结构体"></a>初始化ADC初始化结构体</h3><p>首先是初始化ADC时钟:ADC需要两个时钟，一个是外设时钟，另一个是采样时钟<br>第一步初始化的是ADC2的外设时钟：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">RCC_APB2PeriphClockCmd(RCC_APB2Periph_ADC2,ENABLE);</span><br></pre></td></tr></table></figure>
<p><img src="https://s1.ax1x.com/2020/07/26/a9KojS.png" alt="ADC初始化结构体"><br>之后是配置ADC工作模式,由于选用的是独立模式单通道，所以ADC工作参数具体<br>配置为：独立模式、单通道采集不需要扫描、启动连续转换、使用内部软件触发无<br>需外部触发事件、使用右对齐数据格式、转换通道为 1，并调用 ADC_Init函数完<br>成ADC工作环境配置。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">ADC_InitStruct.ADC_Mode = ADC_Mode_Independent;//独立模式</span><br><span class="line">ADC_InitStruct.ADC_ScanConvMode = DISABLE;//禁止扫描模式，多通道才需要扫描，单通道不需要</span><br><span class="line">ADC_InitStruct.ADC_ContinuousConvMode = ENABLE;//连续扫描模式</span><br><span class="line">ADC_InitStruct.ADC_ExternalTrigConv = ADC_ExternalTrigConv_None;//不用外部触发转换，软件开启即可</span><br><span class="line">ADC_InitStruct.ADC_DataAlign = ADC_DataAlign_Right;//转换结果右对齐</span><br><span class="line">ADC_InitStruct.ADC_NbrOfChannel = 1;//转换通道一个</span><br></pre></td></tr></table></figure>
<p>将配置好的结构体成员写到寄存器里面</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ADC_Init(ADC2,&amp;ADC_InitStruct);//初始化ADC</span><br></pre></td></tr></table></figure>
<p>RCC_ADCCLKConfig()函数用来配置 ADC 的工作时钟，接收一个参数，设置的是<br>PCLK2 的分频系数， ADC 的时钟最大不能超过 14M。<br>ADC_RegularChannelConfig 函数用来绑定 ADC 通道的转换顺序和采样时间。它接收 4<br>个形参，第一个形参选择 ADC 外设，可为 ADC1、 ADC2 或 ADC3；第二个形参通道选择，<br>总共可选 18 个通道；第三个形参为通道的转换顺序，可选为 1 到 16；第四个形参为采样<br>周期选择，采样周期越短， ADC 转换数据输出周期就越短但数据精度也越低，采样周期越<br>长，ADC转换数据输出周期就越长同时数据精度越高。<br>利用ADC转换完成中断可以非常方便的保证我们读取到的数据是转换完成后的数据<br>而不用担心该数据可能是 ADC 正在转换时“不稳定”的数据。我们使用ADC_ITConfig函<br>数使能ADC转换完成中断，并在中断服务函数中读取转换结果数据。<br>ADC_Cmd 函数控制ADC转换启动和停止。<br>最后，在ADC校准之后调用 ADC_SoftwareStartConvCmd 函数进行软件触发 ADC 开<br>始转换。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">      //配置ADC时钟为PCLK的8分频，即9MHZ</span><br><span class="line">RCC_ADCCLKConfig(RCC_PCLK2_Div8);</span><br><span class="line">//配置ADC通道转换顺序和采样时间</span><br><span class="line">ADC_RegularChannelConfig(ADCx,ADC_Channel_1,1,ADC_SampleTime_55Cycles5);</span><br><span class="line">   //adc转换结束产生中断，在中断服务函数中读取转换值</span><br><span class="line">ADC_ITConfig(ADCx,ADC_IT_EOC,ENABLE);</span><br><span class="line">//开启ADC并开始转换</span><br><span class="line">ADC_Cmd(ADCx,ENABLE);</span><br><span class="line">//初始化ADC,校准寄存器</span><br><span class="line">ADC_ResetCalibration(ADCx);</span><br><span class="line">//等待校准寄存器初始化完成</span><br><span class="line"><span class="keyword">while</span>(ADC_GetResetCalibrationStatus(ADCx));</span><br><span class="line">//adc开始校准</span><br><span class="line">ADC_StartCalibration(ADCx);</span><br><span class="line">//等待校准完成</span><br><span class="line"><span class="keyword">while</span>(ADC_GetCalibrationStatus(ADCx));</span><br><span class="line">//由于没有采用外部触发，所以使用软件触发ADC转换</span><br><span class="line">ADC_SoftwareStartConvCmd(ADCx,ENABLE);</span><br></pre></td></tr></table></figure>
<h3 id="ADC中断配置"><a href="#ADC中断配置" class="headerlink" title="ADC中断配置"></a>ADC中断配置</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">static void ADCx_NVIC_Config(void)</span><br><span class="line">&#123;</span><br><span class="line">		NVIC_InitTypeDef  NVIC_InitStruct;</span><br><span class="line">		//中断优先级分组</span><br><span class="line">		NVIC_PriorityGroupConfig(NVIC_PriorityGroup_1);</span><br><span class="line">		NVIC_InitStruct.NVIC_IRQChannel = ADC_IRQ;</span><br><span class="line">		NVIC_InitStruct.NVIC_IRQChannelPreemptionPriority = 1;</span><br><span class="line">	  NVIC_InitStruct.NVIC_IRQChannelSubPriority = 1;</span><br><span class="line">		NVIC_InitStruct.NVIC_IRQChannelCmd = ENABLE;</span><br><span class="line">		NVIC_Init(&amp;NVIC_InitStruct);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="ADC初始化-1"><a href="#ADC初始化-1" class="headerlink" title="ADC初始化"></a>ADC初始化</h2><p>配置完以上三步，ADC即可完成初始化最后通过ADCx_Init()函数使得初始化简易</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">void ADCx_Init(void)</span><br><span class="line">&#123;</span><br><span class="line">		ADCx_GPIO_Config();</span><br><span class="line">		ADCx_NVIC_Config();</span><br><span class="line">		ADCx_Mode_Config();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>之后只需要在主函数里面直接调用ADCx_Init();即可完成ADC的初始化。</p>
<h2 id="读取ADC"><a href="#读取ADC" class="headerlink" title="读取ADC"></a>读取ADC</h2><p>ADC完成转换之后会产生中断，我们只需要配置中断服务函数即可完成对<br>ADC的读取，读取完成后手动清除中断标志位。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">void ADC_IRQHandler(void)</span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">if</span>(ADC_GetITStatus(ADCx,ADC_IT_EOC)==SET)</span><br><span class="line">	&#123;</span><br><span class="line">		ADC_ConvertedValue = ADC_GetConversionValue(ADCx);</span><br><span class="line">	&#125;</span><br><span class="line">	ADC_ClearITPendingBit(ADCx,ADC_IT_EOC);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
      
    </div>
    <footer class="article-footer">
      <a data-url="https://zwz522623.github.io.git/2020/07/26/stm32_ADC(%E7%8B%AC%E7%AB%8B%E6%A8%A1%E5%BC%8F%E5%8D%95%E9%80%9A%E9%81%93)/" data-id="ckd2r07bn0000ewur38zi8gwx" class="article-share-link">分享</a>
      
      
    </footer>
  </div>
  
</article>




  
    <article id="post-EXTI初体验_(&#39;&#39;&#39;)" class="wow slideInRight article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2020/07/25/EXTI%E5%88%9D%E4%BD%93%E9%AA%8C_(''')/" class="article-date">
  <time class="post-time" datetime="2020-07-25T09:28:10.385Z" itemprop="datePublished">
    <span class="post-month">7月</span><br/>
    <span class="post-day">25</span>
  </time>
</a>
   
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2020/07/25/EXTI%E5%88%9D%E4%BD%93%E9%AA%8C_(''')/">EXTI外部中断/事件控制器</a>
    </h1>
  

        <div>
          
          
              

          
        </div>
      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h2 id="编程步骤"><a href="#编程步骤" class="headerlink" title="编程步骤"></a>编程步骤</h2><h3 id="初始化要连接到EXTI的GPIO"><a href="#初始化要连接到EXTI的GPIO" class="headerlink" title="初始化要连接到EXTI的GPIO"></a>初始化要连接到EXTI的GPIO</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">GPIO_InitTypeDef GPIO_InitStruct;</span><br><span class="line">//初始化要连接到EXTI的GPIO</span><br><span class="line">RCC_APB2PeriphClockCmd(Key1_Clock|Key2_Clock,ENABLE);</span><br><span class="line"></span><br><span class="line">GPIO_InitStruct.GPIO_Pin = Key1_Pin;</span><br><span class="line">GPIO_InitStruct.GPIO_Mode = GPIO_Mode_IN_FLOATING;</span><br><span class="line">GPIO_Init(Key1_Port,&amp;GPIO_InitStruct);</span><br><span class="line">GPIO_InitStruct.GPIO_Pin = Key2_Pin;</span><br><span class="line">GPIO_InitStruct.GPIO_Mode = GPIO_Mode_IN_FLOATING;</span><br><span class="line">GPIO_Init(Key2_Port,&amp;GPIO_InitStruct);</span><br></pre></td></tr></table></figure>
<h3 id="初始化EXTI用于产生中断-事件（记得使能AFIO时钟）"><a href="#初始化EXTI用于产生中断-事件（记得使能AFIO时钟）" class="headerlink" title="初始化EXTI用于产生中断/事件（记得使能AFIO时钟）"></a>初始化EXTI用于产生中断/事件（记得使能AFIO时钟）</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">   EXTI_InitTypeDef EXTI_InitStruct;</span><br><span class="line">   //初始化EXTI外设</span><br><span class="line">RCC_APB2PeriphClockCmd(RCC_APB2Periph_AFIO,ENABLE);//初始化AFIO时钟</span><br><span class="line">GPIO_EXTILineConfig(Key2_GPIO_PortSource,Key2_GPIO_PinSource); </span><br><span class="line">EXTI_InitStruct.EXTI_Line = Key2_EXTI;</span><br><span class="line">EXTI_InitStruct.EXTI_Mode = EXTI_Mode_Interrupt;</span><br><span class="line">EXTI_InitStruct.EXTI_Trigger = EXTI_Trigger_Rising;//上升沿触发</span><br><span class="line">EXTI_InitStruct.EXTI_LineCmd = ENABLE;</span><br><span class="line">EXTI_Init(&amp;EXTI_InitStruct);</span><br><span class="line">GPIO_EXTILineConfig(Key1_GPIO_PortSource,Key1_GPIO_PinSource); </span><br><span class="line">EXTI_InitStruct.EXTI_Line = Key1_EXTI;</span><br><span class="line">EXTI_InitStruct.EXTI_Mode = EXTI_Mode_Interrupt;</span><br><span class="line">EXTI_InitStruct.EXTI_Trigger = EXTI_Trigger_Falling;//下降沿触发</span><br><span class="line">EXTI_InitStruct.EXTI_LineCmd = ENABLE;</span><br><span class="line">EXTI_Init(&amp;EXTI_InitStruct);</span><br></pre></td></tr></table></figure>
<p>GPIO_EXTILineConfig函数是选择中断源的GPIO函数<br>EXTI_Line是选择输入线从EXTI_Line0到EXTI_Line19<br>EXTI_Mode有两个选择，一个是EXTI_Mode_Interrupt，另一个是EXTI_Mode_Event<br>EXTI_Trigger通过配置这个可以选择触发方式</p>
<h3 id="初始化NVIC用于处理中断"><a href="#初始化NVIC用于处理中断" class="headerlink" title="初始化NVIC用于处理中断"></a>初始化NVIC用于处理中断</h3><p>由于NVIC只需要调用一次，所以加上static，并在初始化EXTI时直接调用即可<br>系统框图如下<br><img src="https://s1.ax1x.com/2020/07/25/aSZDEV.png" alt="系统框图"><br>初始化NVIC分为以下几步：<br>第一步：<br>    通过NVIC_PriorityGroupConfig()函数配置中断优先级分组从0-4共五组<br>第二步：<br>    配置NVIC初始化结构体<br>    NVIC_InitStruct.NVIC_IRQChannel中断源，中断源在misc.h中有描述<br>    NVIC_InitStruct.NVIC_IRQChannelPreemptionPriority 主优先级<br>    NVIC_InitStruct.NVIC_IRQChannelSubPriority        子优先级<br>    NVIC_InitStruct.NVIC_IRQChannelCmd              使能或失能<br>第三步：<br>    调用NVIC初始化函数把配置好的结构体成员写到寄存器里面</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">static void NVIC_Config(void)    //全局，只需配置一次</span><br><span class="line">&#123;</span><br><span class="line">	NVIC_InitTypeDef NVIC_InitStruct;</span><br><span class="line">	//配置中断优先级分组</span><br><span class="line">	NVIC_PriorityGroupConfig(NVIC_PriorityGroup_1);</span><br><span class="line">	//配置NVIC初始化结构体</span><br><span class="line">	NVIC_InitStruct.NVIC_IRQChannel = Key2_NVIC_IRQChannel;</span><br><span class="line">	NVIC_InitStruct.NVIC_IRQChannelPreemptionPriority = 0;//主优先级</span><br><span class="line">	NVIC_InitStruct.NVIC_IRQChannelSubPriority = 0;//子优先级</span><br><span class="line">    NVIC_InitStruct.NVIC_IRQChannelCmd = ENABLE;</span><br><span class="line">	//调用NVIC初始化函数把配置好的结构体成员写到寄存器里面</span><br><span class="line">	NVIC_Init(&amp;NVIC_InitStruct);</span><br><span class="line">	</span><br><span class="line">	NVIC_InitStruct.NVIC_IRQChannel = Key1_NVIC_IRQChannel;</span><br><span class="line">	NVIC_InitStruct.NVIC_IRQChannelPreemptionPriority = 0;//主优先级</span><br><span class="line">	NVIC_InitStruct.NVIC_IRQChannelSubPriority = 1;//子优先级</span><br><span class="line">    NVIC_InitStruct.NVIC_IRQChannelCmd = ENABLE;	</span><br><span class="line">	</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>直到上面初始化就已经结束啦，下面附上完整的代码<br>exti.h</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#ifndef _EXTI_H</span></span><br><span class="line"><span class="comment">#define _EXTI_H</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#include "stm32f10x.h"</span></span><br><span class="line"><span class="comment">#include "core_cm3.h"</span></span><br><span class="line"><span class="comment">#include "misc.h"</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#define Key1_Clock            RCC_APB2Periph_GPIOC</span></span><br><span class="line"><span class="comment">#define Key1_Port             GPIOC</span></span><br><span class="line"><span class="comment">#define Key1_Pin              GPIO_Pin_13</span></span><br><span class="line"><span class="comment">#define Key1_GPIO_PortSource  GPIO_PortSourceGPIOC  </span></span><br><span class="line"><span class="comment">#define Key1_GPIO_PinSource   GPIO_PinSource13</span></span><br><span class="line"><span class="comment">#define Key1_EXTI             EXTI_Line13</span></span><br><span class="line"><span class="comment">#define Key1_NVIC_IRQChannel  EXTI15_10_IRQn</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#define Key2_Clock            RCC_APB2Periph_GPIOA</span></span><br><span class="line"><span class="comment">#define Key2_Port             GPIOA</span></span><br><span class="line"><span class="comment">#define Key2_Pin              GPIO_Pin_0</span></span><br><span class="line"><span class="comment">#define Key2_GPIO_PortSource  GPIO_PortSourceGPIOA</span></span><br><span class="line"><span class="comment">#define Key2_GPIO_PinSource   GPIO_PinSource0</span></span><br><span class="line"><span class="comment">#define Key2_EXTI             EXTI_Line0</span></span><br><span class="line"><span class="comment">#define Key2_NVIC_IRQChannel  EXTI0_IRQn</span></span><br><span class="line"></span><br><span class="line">static void NVIC_Config(void);</span><br><span class="line">void EXTI_Key_Config(void);</span><br><span class="line"><span class="comment">#endif</span></span><br></pre></td></tr></table></figure>
<p>exti.c</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#include "exti.h"    </span></span><br><span class="line"></span><br><span class="line">static void NVIC_Config(void)    //全局，只需配置一次</span><br><span class="line">&#123;</span><br><span class="line">	NVIC_InitTypeDef NVIC_InitStruct;</span><br><span class="line">	//配置中断优先级分组</span><br><span class="line">	NVIC_PriorityGroupConfig(NVIC_PriorityGroup_1);</span><br><span class="line">	//配置NVIC初始化结构体</span><br><span class="line">	NVIC_InitStruct.NVIC_IRQChannel = Key2_NVIC_IRQChannel;</span><br><span class="line">	NVIC_InitStruct.NVIC_IRQChannelPreemptionPriority = 0;//主优先级</span><br><span class="line">	NVIC_InitStruct.NVIC_IRQChannelSubPriority = 0;//子优先级</span><br><span class="line">  NVIC_InitStruct.NVIC_IRQChannelCmd = ENABLE;</span><br><span class="line">	//调用NVIC初始化函数把配置好的结构体成员写到寄存器里面</span><br><span class="line">	NVIC_Init(&amp;NVIC_InitStruct);</span><br><span class="line">	</span><br><span class="line">	NVIC_InitStruct.NVIC_IRQChannel = Key1_NVIC_IRQChannel;</span><br><span class="line">	NVIC_InitStruct.NVIC_IRQChannelPreemptionPriority = 0;//主优先级</span><br><span class="line">	NVIC_InitStruct.NVIC_IRQChannelSubPriority = 1;//子优先级</span><br><span class="line">  NVIC_InitStruct.NVIC_IRQChannelCmd = ENABLE;	</span><br><span class="line">	</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void EXTI_Key_Config()                                  </span><br><span class="line">&#123;</span><br><span class="line">	GPIO_InitTypeDef GPIO_InitStruct;</span><br><span class="line">	EXTI_InitTypeDef EXTI_InitStruct;</span><br><span class="line">	NVIC_Config();</span><br><span class="line">	//初始化要连接到EXTI的GPIO</span><br><span class="line">	RCC_APB2PeriphClockCmd(Key1_Clock|Key2_Clock,ENABLE);</span><br><span class="line">	</span><br><span class="line">	GPIO_InitStruct.GPIO_Pin = Key1_Pin;</span><br><span class="line">	GPIO_InitStruct.GPIO_Mode = GPIO_Mode_IN_FLOATING;</span><br><span class="line">	GPIO_Init(Key1_Port,&amp;GPIO_InitStruct);</span><br><span class="line">	GPIO_InitStruct.GPIO_Pin = Key2_Pin;</span><br><span class="line">	GPIO_InitStruct.GPIO_Mode = GPIO_Mode_IN_FLOATING;</span><br><span class="line">	GPIO_Init(Key2_Port,&amp;GPIO_InitStruct);</span><br><span class="line">  //初始化EXTI外设</span><br><span class="line">	RCC_APB2PeriphClockCmd(RCC_APB2Periph_AFIO,ENABLE);//初始化AFIO时钟</span><br><span class="line">	GPIO_EXTILineConfig(Key2_GPIO_PortSource,Key2_GPIO_PinSource); </span><br><span class="line">	EXTI_InitStruct.EXTI_Line = Key2_EXTI;</span><br><span class="line">	EXTI_InitStruct.EXTI_Mode = EXTI_Mode_Interrupt;</span><br><span class="line">	EXTI_InitStruct.EXTI_Trigger = EXTI_Trigger_Rising;//上升沿触发</span><br><span class="line">	EXTI_InitStruct.EXTI_LineCmd = ENABLE;</span><br><span class="line">	EXTI_Init(&amp;EXTI_InitStruct);</span><br><span class="line">	</span><br><span class="line">	GPIO_EXTILineConfig(Key1_GPIO_PortSource,Key1_GPIO_PinSource); </span><br><span class="line">	EXTI_InitStruct.EXTI_Line = Key1_EXTI;</span><br><span class="line">	EXTI_InitStruct.EXTI_Mode = EXTI_Mode_Interrupt;</span><br><span class="line">	EXTI_InitStruct.EXTI_Trigger = EXTI_Trigger_Falling;//下降沿触发</span><br><span class="line">	EXTI_InitStruct.EXTI_LineCmd = ENABLE;</span><br><span class="line">	EXTI_Init(&amp;EXTI_InitStruct);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>但是到目前为止，只是完成了初始化，还需要编写中断服务函数，中断服务函数的名字<br>为固定的，可以在misc.h处找到。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">void EXTI0_IRQHandler()</span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">if</span>((EXTI_GetITStatus(Key2_EXTI)) != RESET)</span><br><span class="line">	&#123;</span><br><span class="line">		int i;</span><br><span class="line">		i++;</span><br><span class="line">	&#125;</span><br><span class="line">	EXTI_ClearITPendingBit(Key2_EXTI);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void EXTI15_10_IRQHandler()</span><br><span class="line">&#123;</span><br><span class="line">		<span class="keyword">if</span>((EXTI_GetITStatus(Key1_EXTI)) != RESET)</span><br><span class="line">	&#123;</span><br><span class="line">		int i;</span><br><span class="line">		i++;</span><br><span class="line">	&#125;</span><br><span class="line">	EXTI_ClearITPendingBit(Key1_EXTI);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="最后一步"><a href="#最后一步" class="headerlink" title="最后一步"></a>最后一步</h3><p>在main函数里面调用初始化即可等待中断。</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="https://zwz522623.github.io.git/2020/07/25/EXTI%E5%88%9D%E4%BD%93%E9%AA%8C_(''')/" data-id="ckd1gl3jc0000okur0dbcfsbc" class="article-share-link">分享</a>
      
      
    </footer>
  </div>
  
</article>




  
    <article id="post-STM32中断概述" class="wow slideInRight article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2020/07/25/STM32%E4%B8%AD%E6%96%AD%E6%A6%82%E8%BF%B0/" class="article-date">
  <time class="post-time" datetime="2020-07-25T03:04:05.953Z" itemprop="datePublished">
    <span class="post-month">7月</span><br/>
    <span class="post-day">25</span>
  </time>
</a>
   
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2020/07/25/STM32%E4%B8%AD%E6%96%AD%E6%A6%82%E8%BF%B0/">STM32中断概述（不止于F103）</a>
    </h1>
  

        <div>
          
          
              

          
        </div>
      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h2 id="中断应用概念"><a href="#中断应用概念" class="headerlink" title="中断应用概念"></a>中断应用概念</h2><h3 id="中断类型"><a href="#中断类型" class="headerlink" title="中断类型"></a>中断类型</h3><p>系统中断：体现在内核水平<br>外部中断：体现在外设水平</p>
<h2 id="NVIC嵌套向量中断控制器"><a href="#NVIC嵌套向量中断控制器" class="headerlink" title="NVIC嵌套向量中断控制器"></a>NVIC嵌套向量中断控制器</h2><h3 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h3><p>NVIC:嵌套向量中断控制器，属于内核外设，管理着包括内核和片上所有<br>外设的相关功能。<br>两个重要的库文件：<br>                core_cm3.h  定义寄存器<br>                misc.h      定义相关函数</p>
<h3 id="中断优先级的定义"><a href="#中断优先级的定义" class="headerlink" title="中断优先级的定义"></a>中断优先级的定义</h3><h4 id="优先级的设定"><a href="#优先级的设定" class="headerlink" title="优先级的设定"></a>优先级的设定</h4><p>中断优先级由IPR寄存器设定：NVIC-&gt;IPRx<br>设定函数:</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">NVIC_SetPriority(IRQn_TypeIRQn,uint32_t priority);  //中断号，中断优先级</span><br></pre></td></tr></table></figure>

<h4 id="中断优先级的分组"><a href="#中断优先级的分组" class="headerlink" title="中断优先级的分组"></a>中断优先级的分组</h4><p>优先级分组                主优先级            子优先级<br>NVIC_PriorityGroup_0        0              0-15<br>NVIC_PriorityGroup_1        1              0-7<br>NVIC_PriorityGroup_2       0-3             0-3<br>NVIC_PriorityGroup_3       0-7             0-1<br>NVIC_PriorityGroup_4       0-15             0<br>设定函数：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">NVIC_PriorityGroupConfig(uint32_t NVIC_PriorityGroup);</span><br></pre></td></tr></table></figure>

<h3 id="中断编程顺序"><a href="#中断编程顺序" class="headerlink" title="中断编程顺序"></a>中断编程顺序</h3><pre><code>       使能中断请求
           |
           V
    配置中断优先级分组
           |
           V
配置NVIC寄存器，初始化NVIC_InitTypeDef;
           |
           V
     编写中断服务函数</code></pre><h4 id="使能中断请求"><a href="#使能中断请求" class="headerlink" title="使能中断请求"></a>使能中断请求</h4><p>该项具体到外设</p>
<h4 id="中断优先级分组"><a href="#中断优先级分组" class="headerlink" title="中断优先级分组"></a>中断优先级分组</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">NVIC_PriorityGroupConfig(uint32_t NVIC_PriorityGroup);</span><br></pre></td></tr></table></figure>
<h4 id="NVIC-InitTypeDef"><a href="#NVIC-InitTypeDef" class="headerlink" title="NVIC_InitTypeDef"></a>NVIC_InitTypeDef</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">NVIC_InitStruct.NVIC_IRQChannel:中断源</span><br><span class="line">NVIC_InitStruct.NVIC_IRQChannelPreemptionPriority：抢占优先级</span><br><span class="line">NVIC_InitStruct.NVIC_IRQChannelSubPriority：子优先级</span><br><span class="line">NVIC_InitStruct.NVIC_IRQChannelCmd：使能或失能</span><br><span class="line">NVIC_Init();</span><br></pre></td></tr></table></figure>

<h4 id="编写中断服务函数"><a href="#编写中断服务函数" class="headerlink" title="编写中断服务函数"></a>编写中断服务函数</h4><p>中断服务函数名称要与中断向量表中一至，否则进不去中断<br>stm32f10x_it.c默认放置中断服务函数，方便分配优先级</p>
<p><img src="https://image.baidu.com/search/detail?ct=503316480&z=undefined&tn=baiduimagedetail&ipn=d&word=%E5%A5%A5%E5%B0%94%E5%8A%A0%E4%B8%8D%E8%A6%81%E5%81%9C%E4%B8%8B%E6%9D%A5&step_word=&ie=utf-8&in=&cl=2&lm=-1&st=undefined&hd=undefined&latest=undefined&copyright=undefined&cs=1861462371,1849573485&os=2548686085,4258025421&simid=0,0&pn=1&rn=1&di=33020&ln=229&fr=&fmq=1595648989176_R&fm=&ic=undefined&s=undefined&se=&sme=&tab=0&width=undefined&height=undefined&face=undefined&is=0,0&istype=0&ist=&jit=&bdtype=10&spn=0&pi=0&gsm=0&objurl=http%3A%2F%2Ft7.baidu.com%2Fit%2Fu%3D2333738978%2C900919767%26fm%3D193&rpstart=0&rpnum=0&adpicid=0&force=undefined" alt="avatar"></p>

      
    </div>
    <footer class="article-footer">
      <a data-url="https://zwz522623.github.io.git/2020/07/25/STM32%E4%B8%AD%E6%96%AD%E6%A6%82%E8%BF%B0/" data-id="ckd148kdm000038urcm6t5wx4" class="article-share-link">分享</a>
      
      
    </footer>
  </div>
  
</article>




  
    <article id="post-stm32读取按键" class="wow slideInRight article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2020/07/24/stm32%E8%AF%BB%E5%8F%96%E6%8C%89%E9%94%AE/" class="article-date">
  <time class="post-time" datetime="2020-07-24T11:53:05.533Z" itemprop="datePublished">
    <span class="post-month">7月</span><br/>
    <span class="post-day">24</span>
  </time>
</a>
   
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2020/07/24/stm32%E8%AF%BB%E5%8F%96%E6%8C%89%E9%94%AE/">STM32读取按键</a>
    </h1>
  

        <div>
          
          
              

          
        </div>
      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>之前已经通过点灯的方式实现了对GPIO写入的操作，今天要做的便是读取<br>GPIO引脚的状态，引脚电平通过TTL肖特基触发器，大于1.8V的输出为1，<br>低于1.8v的输出为0，加载到ODR寄存器中，通过读取寄存器的值便可以读<br>出引脚的状态。</p>
<h2 id="读取按键"><a href="#读取按键" class="headerlink" title="读取按键"></a>读取按键</h2><h2 id="第一步：初始化GPIO"><a href="#第一步：初始化GPIO" class="headerlink" title="第一步：初始化GPIO"></a>第一步：初始化GPIO</h2><h3 id="宏定义引脚，增加可读性"><a href="#宏定义引脚，增加可读性" class="headerlink" title="宏定义引脚，增加可读性"></a>宏定义引脚，增加可读性</h3><p>为了使程序更加的清晰，同时也是为了增加程序的可移植性，在程序里面<br>关于引脚的定义选择宏定义，具体操作如下：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#define Key1_GPIO_CLK   RCC_APB2Periph_GPIOC</span></span><br><span class="line"><span class="comment">#define Key1_GPIO_Port  GPIOC</span></span><br><span class="line"><span class="comment">#define Key1_GPIO_Pin   GPIO_Pin_13</span></span><br></pre></td></tr></table></figure>
<p>宏定义将RCC_APB2Periph_GPIOC替换为了Key1_GPIO_CLK，这样在程序<br>里面就可以清楚地看到初始化的是哪一个外设的时钟，程序的可读性也大<br>大的提高了。</p>
<h3 id="初始化GPIO"><a href="#初始化GPIO" class="headerlink" title="初始化GPIO"></a>初始化GPIO</h3><p>初始化GPIO的操作与之前点灯时候的操作大体一致，不过由于按键是输入，<br>所以GPIO_SPEED可以不去配置，初始化代码如下:</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">void Key_Init()</span><br><span class="line">&#123;</span><br><span class="line">	GPIO_InitTypeDef GPIO_InitTStruct;</span><br><span class="line">	//KEY1,KEY2引脚时钟使能</span><br><span class="line">	RCC_APB2PeriphClockCmd(Key1_GPIO_CLK|Key2_GPIO_CLK,ENABLE);//宏定义用Key1_GPIO_CLK代替RCC_APB2Periph_GPIOC</span><br><span class="line">	</span><br><span class="line">	//初始化key1引脚</span><br><span class="line">	GPIO_InitTStruct.GPIO_Pin = Key1_GPIO_Pin;</span><br><span class="line">	GPIO_InitTStruct.GPIO_Mode = GPIO_Mode_IN_FLOATING;</span><br><span class="line">	//GPIO_InitTStruct.GPIO_Speed = GPIO_Speed_10MHz;输出时需要配置速度</span><br><span class="line">	GPIO_Init(Key1_GPIO_Port,&amp;GPIO_InitTStruct);</span><br><span class="line">	</span><br><span class="line">	//初始化key2引脚</span><br><span class="line">	GPIO_InitTStruct.GPIO_Pin = Key2_GPIO_Pin;</span><br><span class="line">	GPIO_InitTStruct.GPIO_Mode = GPIO_Mode_IN_FLOATING;</span><br><span class="line">	GPIO_Init(Key2_GPIO_Port,&amp;GPIO_InitTStruct);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>按键为输入部分，所以引脚模式（GPIO_Mode）设置为浮空输入（GPIO_Mode_IN_FLOATING）。</p>
<h3 id="按键检测"><a href="#按键检测" class="headerlink" title="按键检测"></a>按键检测</h3><p>通过上面的步骤我们已经初始化好了GPIO所需要的的引脚，接下来要做的便是<br>读取到ODR寄存器里面的值，由于库函数已经写好了读取的函数，我们直接调<br>用即可：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">GPIO_ReadInputDataBit(GPIOx,GPIO_Pin)；//这是只读取一个引脚状态的函数</span><br><span class="line">GPIO_ReadInputData(GPIOx);             //读取这个端口里所有的引脚的值</span><br></pre></td></tr></table></figure>
<p>按键检测函数：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">uint16_t Keyscan(GPIO_TypeDef* GPIOx,uint16_t GPIO_Pin)  //按键扫描函数</span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">if</span>(GPIO_ReadInputDataBit(GPIOx,GPIO_Pin))</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">while</span>(GPIO_ReadInputDataBit(GPIOx,GPIO_Pin)==Key_On);//松手检测</span><br><span class="line">		<span class="built_in">return</span> Key_On;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">else</span></span><br><span class="line">	 <span class="built_in">return</span> Key_Off;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>按键检测这就差不多结束了，之后只需要调用Keyscan()这个函数即可，具体<br>功能可以自行决定。</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="https://zwz522623.github.io.git/2020/07/24/stm32%E8%AF%BB%E5%8F%96%E6%8C%89%E9%94%AE/" data-id="ckd0yk46x0000scur1gt30oxt" class="article-share-link">分享</a>
      
      
    </footer>
  </div>
  
</article>




  
    <article id="post-stm32入门" class="wow slideInRight article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2020/07/24/stm32%E5%85%A5%E9%97%A8/" class="article-date">
  <time class="post-time" datetime="2020-07-24T08:30:20.628Z" itemprop="datePublished">
    <span class="post-month">7月</span><br/>
    <span class="post-day">24</span>
  </time>
</a>
   
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2020/07/24/stm32%E5%85%A5%E9%97%A8/">STM32入门笔记（1）</a>
    </h1>
  

        <div>
          
          
              

          
        </div>
      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p> stm32库函数已经十分完善，学习stm32可以从寄存器开始，这种方法虽然可以<br> 有个很好的理解，但是入门过难，所以我选择了相较与简单的库函数入手学习stm<br> 32这款单片机。</p>
<p>##第一步：（<del>万物基于点灯</del>）<br>点灯其实就是对单片机的管脚口进行操作，控制引脚的高低电平。stm32相较于<br>之前的单片机增加了对引脚的初始化的步骤。<br>    首先是在头文件中添加外设相关的库函数:’stm32f10x.h’<br>    其次是声明结构体变量：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">GPIO_InitTypeDef GPIO_InitStruct;</span><br></pre></td></tr></table></figure>
<p>之后便是使能外设的时钟，时钟由RCC的外设控制，具体内容可以在rcc的头文件<br>中看到，由文档描述可知，所有的GPIO都挂载在APB2总线上，所以选择使能APB2的时<br>钟。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$    RCC_APB2PeriphClockCmd(RCC_APB2Periph_GPIOC,ENABLE);//使能GPIOC的时钟，ENABLE--使能，DISABLE--不使能</span><br></pre></td></tr></table></figure>
<p>下一步便是配置外设初始化结构体，一般名称为:XXXX_InitTypeDef<br>具体顺序为:选择引脚-&gt;选择输出模式-&gt;选择速度</p>
<pre><code class="bash">GPIO_InitStruct.GPIO_Pin = GPIO_Pin_2;             //2号引脚
GPIO_InitStruct.GPIO_Mode = GPIO_Mode_Out_PP;      //PP:推挽输出
GPIO_InitStruct.GPIO_Speed = GPIO_Speed_10MHz;     //速度选择10MHZ</code></pre>
<p>最后一步便是调用外设初始化函数，把配置好的结构体变量写到寄存器里</p>
<pre><code class="bash">GPIO_Init(GPIOC,&amp;GPIO_InitStruct);//由于GPIO_InitStruct为变量，但是函数传入的为指针，所以对变量取地址，输入即为变量</code></pre>
<p>直到上面，引脚的初始化就结束了。之后便是对引脚进行操作。</p>
<pre><code class="bash">GPIO_SetBits(GPIOC,GPIO_Pin_2);//置位
GPIO_ResetBits(GPIOC,GPIO_Pin_2);//复位，输出低</code></pre>
<p>最后附上完整代码:</p>
<pre><code class="bash">void Led_GPIO_Config(void)
{
  GPIO_InitTypeDef GPIO_InitStruct;
  //使能时钟
  RCC_APB2PeriphClockCmd(RCC_APB2Periph_GPIOC,ENABLE);
  //配置外设初始化结构体
  GPIO_InitStruct.GPIO_Pin = GPIO_Pin_2;
  GPIO_InitStruct.GPIO_Mode = GPIO_Mode_Out_PP;
  GPIO_InitStruct.GPIO_Speed = GPIO_Speed_10MHz;
  //调用外设初始化函数，将初始化好的结构体变量写到寄存器里面
  GPIO_Init(GPIOC,&amp;GPIO_InitStruct);
}</code></pre>
<pre><code class="bash">int main(void)
{
  // 来到这里的时候，系统的时钟已经被配置成72M。
  Led_GPIO_Config();
  <span class="keyword">while</span>(1)
  {
    GPIO_SetBits(GPIOC,GPIO_Pin_2);//置位
    delay(500);
    GPIO_ResetBits(GPIOC,GPIO_Pin_2);//复位，输出低
  }
}</code></pre>

      
    </div>
    <footer class="article-footer">
      <a data-url="https://zwz522623.github.io.git/2020/07/24/stm32%E5%85%A5%E9%97%A8/" data-id="ckczz8dd50000nkurhjheay17" class="article-share-link">分享</a>
      
      
    </footer>
  </div>
  
</article>




  


  <nav id="page-nav">
    <span class="page-number current">1</span><a class="page-number" href="/page/2/">2</a><a class="extend next" rel="next" href="/page/2/">next &amp;raquo;</a>
  </nav>
</section>
        
          <aside id="sidebar">
  
    <div class="widget-wrap">
  <h3 class="widget-title"></h3>
  <div class="widget">
    <h1 class="blog-title">张维尊的博客</h1>
    <h2 class="blog-subtitle"></h2>
    <ul class="blog-link">
     
          <a href="/" title="Home">
            <li>主页</li>
          </a>
        
          <a href="/archives" title="Archives">
            <li>归档</li>
          </a>
        
          <a href="/categories" title="Categories">
            <li>分类</li>
          </a>
        
          <a href="/tags" title="Tags">
            <li>标签</li>
          </a>
        
    </ul>
  </div>
</div>

  
    <div class="widget-wrap">
  <h3 class="widget-title"></h3>
  <div class="widget">
    <img class="avatar" src="https://avatars0.githubusercontent.com/u/20333903?v=3&amp;s=460">
    <h2 class="author">尊某</h2>
    <h3 class="description">我们生活的每个日常，都是连续发生的奇迹</h3>
    <div class="count-box">
      <a href="/archives"><div><strong>14</strong><br>文章</div></a>
      <a href="/categories"><div><strong>0</strong><br>分类</div></a>
      <a href="/tags"><div><strong>0</strong><br>标签</div></a>
    </div>



    <div class="social-link">
      
        <a class="hvr-bounce-in" href="http://github.com/ShanaMaid" target="_blank" title="Github">
          Github
        </a>
      
    </div>

    <div class="friend-link">
      <h2>友情链接</h2>
      
        <a class="hvr-bounce-in" href="http://blog.shanamaid.top/" target="_blank" title="ShanaMaid">
          ShanaMaid
        </a>
      
    </div>
  </div>
</div>

  
</aside>
        
      </div>
      <footer id="footer">
  
  <div class="outer">
    <div id="footer-info" class="inner">
      &copy;2019 - 2020 尊某<br>
      由<a href="http://hexo.io/" target="_blank">Hexo</a>强力驱动 | 
      主题-<a href="https://github.com/ShanaMaid/hexo-theme-shana" target="_blank" rel="noopener">Shana</a>
      
    </div>
    
  </div>
</footer>
    </div>
    

<script src="//apps.bdimg.com/libs/jquery/2.1.4/jquery.min.js"></script>
<script src="//apps.bdimg.com/libs/wow/0.1.6/wow.min.js"></script>
<script>
new WOW().init();
</script>   


  
<link rel="stylesheet" href="/plugin/fancybox/jquery.fancybox.css">

  
<script src="/plugin/fancybox/jquery.fancybox.pack.js"></script>




  
<link rel="stylesheet" href="/plugin/galmenu/GalMenu.css">

  
<script src="/plugin/galmenu/GalMenu.js"></script>

  <div class="GalMenu GalDropDown">
      <div class="circle" id="gal">
        <div class="ring">
          
            <a href="/" title="" class="menuItem">首页</a>
          
            <a href="/tags" title="" class="menuItem">标签</a>
          
            <a href="/categories" title="" class="menuItem">分类</a>
          
            <a href="/archives" title="" class="menuItem">归档</a>
          
            <a href="/xxxxxxxxx" title="" class="menuItem">xxx</a>
          
            <a href="/xxxxxxx" title="" class="menuItem">xxxx</a>
          
        </div>
        
          <audio id="audio" src="#"></audio>
        
      </div> 
</div>
<div id="overlay" style="opacity: 1; cursor: pointer;"></div>
  <script type="text/javascript">var items = document.querySelectorAll('.menuItem');
    for (var i = 0,
    l = items.length; i < l; i++) {
      items[i].style.left = (50 - 35 * Math.cos( - 0.5 * Math.PI - 2 * (1 / l) * i * Math.PI)).toFixed(4) + "%";
      items[i].style.top = (50 + 35 * Math.sin( - 0.5 * Math.PI - 2 * (1 / l) * i * Math.PI)).toFixed(4) + "%"
    }</script>
<script type="text/javascript">
  $(document).ready(function() {
    $('body').GalMenu({
      'menu': 'GalDropDown'
    })
  });
</script>

  <section class="hidden-xs"> 
  <ul class="cb-slideshow"> 
    <li><span>苟利</span></li> 
    <li><span>国家</span></li> 
    <li><span>生死以</span></li> 
    <li><span>岂能</span></li> 
    <li><span>祸福</span></li> 
    <li><span>趋避之</span></li> 
  </ul>
</section>

<script src="/js/script.js"></script>




  </div>
<script src="/live2dw/lib/L2Dwidget.min.js?094cbace49a39548bed64abff5988b05"></script><script>L2Dwidget.init({"log":false,"pluginJsPath":"lib/","pluginModelPath":"assets/","pluginRootPath":"live2dw/","tagMode":false});</script></body>
</html>